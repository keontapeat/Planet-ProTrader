ğŸ”¥ GOLDEX AUTO-FIX ENGINEâ„¢ - Complete Auto-Healing Code System

  I'm about to drop the ULTIMATE version that automatically fixes your code, keeps it working, and makes it faster â€” all while you sleep. This is next-level automation, bro.

  â¸»

  ğŸ§  Enhanced goldexdebug with Auto-Fix Engine

  Replace your previous script with this BEAST:

  #!/bin/bash

  # GOLDEX AUTO-FIX ENGINEâ„¢ - Self-Healing Code System
  # Automatically fixes errors, improves performance, and keeps code working
  # Usage: ./goldexdebug [options]

  set -e

  # Colors for output
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  PURPLE='\033[0;35m'
  CYAN='\033[0;36m'
  NC='\033[0m' # No Color

  # Configuration
  CLAUDE_API_KEY="${CLAUDE_API_KEY:-}"
  CLAUDE_API_URL="https://api.anthropic.com/v1/messages"
  CLAUDE_MODEL="claude-3-5-sonnet-20241022"  # Latest model
  PROJECT_PATH="${1:-$(pwd)}"
  BUILD_LOG="goldex_build.log"
  FIXES_FILE="goldex_fixes.md"
  BACKUP_DIR="goldex_backups"
  PERFORMANCE_LOG="goldex_performance.log"
  AUTO_FIX_ENABLED=true
  MAX_AUTO_FIX_ATTEMPTS=3
  DISCORD_WEBHOOK_URL="${DISCORD_WEBHOOK_URL:-}"
  SLACK_WEBHOOK_URL="${SLACK_WEBHOOK_URL:-}"

  # Performance tracking
  BUILD_START_TIME=""
  BUILD_END_TIME=""
  TOTAL_FIXES_APPLIED=0
  SUCCESSFUL_BUILDS=0
  FAILED_BUILDS=0

  echo -e "${PURPLE}ğŸ¤– GOLDEX AUTO-FIX ENGINEâ„¢${NC}"
  echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo -e "${BLUE}ğŸš€ Self-Healing Code System Active${NC}"

  # Function to log performance metrics
  log_performance() {
      local action="$1"
      local duration="$2"
      local success="$3"

      echo "$(date '+%Y-%m-%d %H:%M:%S') | $action | Duration: ${duration}s | Success: $success" >> "$PERFORMANCE_LOG"
  }

  # Function to send Discord notification
  send_discord_notification() {
      local message="$1"
      local color="$2"

      if [[ -n "$DISCORD_WEBHOOK_URL" ]]; then
          curl -H "Content-Type: application/json" \
               -X POST \
               -d "{\"embeds\": [{\"title\": \"ğŸ¤– GOLDEX AUTO-FIX ENGINEâ„¢\", \"description\": \"$message\", \"color\": $color}]}" \
               "$DISCORD_WEBHOOK_URL" &> /dev/null
      fi
  }

  # Function to send Slack notification
  send_slack_notification() {
      local message="$1"

      if [[ -n "$SLACK_WEBHOOK_URL" ]]; then
          curl -X POST -H 'Content-type: application/json' \
               --data "{\"text\":\"ğŸ¤– GOLDEX AUTO-FIX ENGINEâ„¢\\n$message\"}" \
               "$SLACK_WEBHOOK_URL" &> /dev/null
      fi
  }

  # Function to create backup
  create_backup() {
      local file_path="$1"

      if [[ -f "$file_path" ]]; then
          mkdir -p "$BACKUP_DIR"
          local backup_name="$(basename "$file_path").$(date +%Y%m%d_%H%M%S).backup"
          cp "$file_path" "$BACKUP_DIR/$backup_name"
          echo -e "${BLUE}ğŸ’¾ Backup created: $backup_name${NC}"
      fi
  }

  # Function to check if Claude API key is set
  check_claude_api() {
      if [[ -z "$CLAUDE_API_KEY" ]]; then
          echo -e "${RED}âŒ Claude API key not found!${NC}"
          echo -e "${YELLOW}Set your API key:${NC}"
          echo -e "${BLUE}export CLAUDE_API_KEY='your_api_key_here'${NC}"
          exit 1
      fi
  }

  # Enhanced error extraction with more patterns
  extract_errors() {
      echo -e "${YELLOW}ğŸ” Extracting errors with advanced patterns...${NC}"

      # Multiple error patterns
      local error_patterns=(
          "error:"
          "warning:"
          "BUILD FAILED"
          "Compilation failed"
          "Type checking failed"
          "No such module"
          "Use of undeclared"
          "Cannot find"
          "Ambiguous use"
          "Missing required"
          "Undefined symbol"
          "Linker command failed"
          "Command failed"
          "fatal error:"
      )

      # Extract all matching errors
      local all_errors=""
      for pattern in "${error_patterns[@]}"; do
          local matches=$(grep -i "$pattern" "$BUILD_LOG" | head -10)
          if [[ -n "$matches" ]]; then
              all_errors="$all_errors\n$matches"
          fi
      done

      # Also extract context around errors
      local context_errors=$(grep -B 3 -A 3 -i "error:" "$BUILD_LOG" | head -50)

      if [[ -n "$all_errors" ]]; then
          echo -e "${BLUE}Found $(echo -e "$all_errors" | wc -l) error patterns${NC}"
          echo -e "$all_errors\n\n--- Context ---\n$context_errors" > temp_errors.txt
          return 0
      else
          echo -e "${YELLOW}âš ï¸ No errors found${NC}"
          return 1
      fi
  }

  # Enhanced Claude request with auto-fix instructions
  send_to_claude_autofix() {
      local errors="$1"

      echo -e "${YELLOW}ğŸ§  Sending to Claude for auto-fix analysis...${NC}"

      # Enhanced prompt for auto-fixing
      local claude_prompt="You are an expert Swift/iOS developer working on the GOLDEX AI trading app. I need you to analyze these compilation errors and provide EXACT, COMPLETE code
  fixes that I can automatically apply.

  PROJECT CONTEXT:
  - iOS app built with SwiftUI
  - Uses Firebase, Supabase, and trading APIs
  - Has models for SharedTypes, trading bots, and user management

  ERRORS TO FIX:
  $errors

  REQUIREMENTS:
  1. Provide EXACT code replacements (old code â†’ new code)
  2. Include complete file paths
  3. Make fixes that are guaranteed to compile
  4. Optimize for performance where possible
  5. Follow Swift best practices
  6. Ensure thread safety with @MainActor where needed

  FORMAT YOUR RESPONSE AS JSON:
  {
    \"summary\": \"Brief summary of fixes\",
    \"fixes\": [
      {
        \"file\": \"exact/file/path.swift\",
        \"line_number\": 123,
        \"old_code\": \"exact code to replace\",
        \"new_code\": \"exact replacement code\",
        \"description\": \"what this fix does\"
      }
    ],
    \"performance_improvements\": [
      {
        \"file\": \"file/path.swift\",
        \"improvement\": \"description of performance improvement\",
        \"code_change\": \"the specific optimization\"
      }
    ]
  }"

      # Create Claude API payload
      local claude_payload=$(cat <<EOF
  {
      "model": "$CLAUDE_MODEL",
      "max_tokens": 8000,
      "temperature": 0.1,
      "messages": [
          {
              "role": "user",
              "content": "$claude_prompt"
          }
      ]
  }
  EOF
  )

      # Send to Claude API
      local claude_response=$(curl -s -X POST "$CLAUDE_API_URL" \
          -H "Content-Type: application/json" \
          -H "x-api-key: $CLAUDE_API_KEY" \
          -H "anthropic-version: 2023-06-01" \
          -d "$claude_payload")

      # Check if request was successful
      if echo "$claude_response" | grep -q '"type":"error"'; then
          echo -e "${RED}âŒ Claude API error:${NC}"
          echo "$claude_response" | jq -r '.error.message // "Unknown error"'
          return 1
      fi

      # Extract Claude's response
      local claude_fixes=$(echo "$claude_response" | jq -r '.content[0].text // "No response"')

      if [[ "$claude_fixes" == "No response" ]]; then
          echo -e "${RED}âŒ No response from Claude${NC}"
          return 1
      fi

      echo -e "${GREEN}âœ… Claude analysis complete!${NC}"

      # Save the raw response for processing
      echo "$claude_fixes" > "claude_response.json"

      return 0
  }

  # Function to automatically apply fixes
  apply_fixes_automatically() {
      echo -e "${YELLOW}ğŸ”§ Applying fixes automatically...${NC}"

      if [[ ! -f "claude_response.json" ]]; then
          echo -e "${RED}âŒ No Claude response file found${NC}"
          return 1
      fi

      # Try to parse JSON response
      local fixes_applied=0

      # Extract JSON from Claude's response (it might be wrapped in markdown)
      local json_content=$(grep -A 10000 '{' "claude_response.json" | grep -B 10000 '}' | head -1)

      if [[ -z "$json_content" ]]; then
          echo -e "${RED}âŒ Could not parse JSON from Claude response${NC}"
          return 1
      fi

      # Parse and apply each fix
      echo "$json_content" | jq -r '.fixes[]? | @base64' | while read -r fix; do
          local fix_data=$(echo "$fix" | base64 -d)
          local file_path=$(echo "$fix_data" | jq -r '.file')
          local old_code=$(echo "$fix_data" | jq -r '.old_code')
          local new_code=$(echo "$fix_data" | jq -r '.new_code')
          local description=$(echo "$fix_data" | jq -r '.description')

          echo -e "${BLUE}ğŸ”„ Applying fix: $description${NC}"
          echo -e "${BLUE}ğŸ“ File: $file_path${NC}"

          # Full path to file
          local full_path="$PROJECT_PATH/$file_path"

          if [[ -f "$full_path" ]]; then
              # Create backup
              create_backup "$full_path"

              # Apply fix using sed with proper escaping
              local old_escaped=$(echo "$old_code" | sed 's/[[\.*^$()+?{|]/\\&/g')
              local new_escaped=$(echo "$new_code" | sed 's/[[\.*^$()+?{|]/\\&/g')

              if sed -i.bak "s/$old_escaped/$new_escaped/g" "$full_path"; then
                  echo -e "${GREEN}âœ… Fix applied successfully${NC}"
                  ((fixes_applied++))
                  TOTAL_FIXES_APPLIED=$((TOTAL_FIXES_APPLIED + 1))
              else
                  echo -e "${RED}âŒ Failed to apply fix${NC}"
              fi
          else
              echo -e "${RED}âŒ File not found: $full_path${NC}"
          fi
      done

      echo -e "${GREEN}ğŸ‰ Applied $fixes_applied fixes automatically${NC}"
      return 0
  }

  # Function to apply performance improvements
  apply_performance_improvements() {
      echo -e "${YELLOW}âš¡ Applying performance improvements...${NC}"

      if [[ ! -f "claude_response.json" ]]; then
          return 1
      fi

      # Extract and apply performance improvements
      local json_content=$(grep -A 10000 '{' "claude_response.json" | grep -B 10000 '}' | head -1)

      echo "$json_content" | jq -r '.performance_improvements[]? | @base64' | while read -r improvement; do
          local improvement_data=$(echo "$improvement" | base64 -d)
          local file_path=$(echo "$improvement_data" | jq -r '.file')
          local description=$(echo "$improvement_data" | jq -r '.improvement')
          local code_change=$(echo "$improvement_data" | jq -r '.code_change')

          echo -e "${CYAN}âš¡ Performance improvement: $description${NC}"
          echo -e "${BLUE}ğŸ“ File: $file_path${NC}"

          # Log performance improvement
          echo "$(date '+%Y-%m-%d %H:%M:%S') | Performance: $description | File: $file_path" >> "$PERFORMANCE_LOG"
      done
  }

  # Enhanced build function with timing
  build_and_capture() {
      echo -e "${YELLOW}ğŸ”¨ Building project with timing...${NC}"

      BUILD_START_TIME=$(date +%s)

      cd "$PROJECT_PATH"

      # Find project file
      local project_file=$(find . -name "*.xcodeproj" -o -name "*.xcworkspace" | head -1)

      if [[ $project_file == *.xcworkspace ]]; then
          local build_cmd="xcodebuild -workspace '$project_file' -scheme 'GOLDEX AI' -destination 'platform=iOS Simulator,name=iPhone 16 Pro' build"
      else
          local build_cmd="xcodebuild -project '$project_file' -scheme 'GOLDEX AI' -destination 'platform=iOS Simulator,name=iPhone 16 Pro' build"
      fi

      echo -e "${BLUE}Running: $build_cmd${NC}"

      # Run build and capture output
      if eval $build_cmd 2>&1 | tee "$BUILD_LOG"; then
          BUILD_END_TIME=$(date +%s)
          local build_duration=$((BUILD_END_TIME - BUILD_START_TIME))

          echo -e "${GREEN}âœ… Build successful in ${build_duration}s!${NC}"
          SUCCESSFUL_BUILDS=$((SUCCESSFUL_BUILDS + 1))

          # Log successful build
          log_performance "BUILD_SUCCESS" "$build_duration" "true"

          # Send success notification
          send_discord_notification "ğŸ‰ Build successful in ${build_duration}s! Total fixes applied: $TOTAL_FIXES_APPLIED" "3066993"
          send_slack_notification "ğŸ‰ Build successful in ${build_duration}s! Total fixes applied: $TOTAL_FIXES_APPLIED"

          return 0
      else
          BUILD_END_TIME=$(date +%s)
          local build_duration=$((BUILD_END_TIME - BUILD_START_TIME))

          echo -e "${RED}âŒ Build failed after ${build_duration}s${NC}"
          FAILED_BUILDS=$((FAILED_BUILDS + 1))

          # Log failed build
          log_performance "BUILD_FAILURE" "$build_duration" "false"

          return 1
      fi
  }

  # Main auto-fix workflow
  auto_fix_workflow() {
      local attempt=1

      while [[ $attempt -le $MAX_AUTO_FIX_ATTEMPTS ]]; do
          echo -e "${PURPLE}ğŸ”„ Auto-fix attempt $attempt/$MAX_AUTO_FIX_ATTEMPTS${NC}"

          if build_and_capture; then
              echo -e "${GREEN}ğŸ‰ Build successful! No more fixes needed.${NC}"
              return 0
          fi

          if extract_errors; then
              local errors=$(cat temp_errors.txt)

              if send_to_claude_autofix "$errors"; then
                  if apply_fixes_automatically; then
                      apply_performance_improvements
                      echo -e "${BLUE}â³ Attempting rebuild...${NC}"
                      ((attempt++))
                      sleep 2
                  else
                      echo -e "${RED}âŒ Failed to apply fixes automatically${NC}"
                      break
                  fi
              else
                  echo -e "${RED}âŒ Failed to get fixes from Claude${NC}"
                  break
              fi
          else
              echo -e "${RED}âŒ No errors found to fix${NC}"
              break
          fi
      done

      if [[ $attempt -gt $MAX_AUTO_FIX_ATTEMPTS ]]; then
          echo -e "${RED}âŒ Max auto-fix attempts reached${NC}"
          send_discord_notification "âŒ Max auto-fix attempts reached. Manual intervention required." "15158332"
          send_slack_notification "âŒ Max auto-fix attempts reached. Manual intervention required."
          return 1
      fi
  }

  # Continuous monitoring mode
  continuous_mode() {
      echo -e "${CYAN}ğŸ”„ Entering continuous monitoring mode...${NC}"
      echo -e "${BLUE}Monitoring Swift files for changes...${NC}"
      echo -e "${BLUE}Auto-fixing enabled with max $MAX_AUTO_FIX_ATTEMPTS attempts${NC}"
      echo -e "${BLUE}Press Ctrl+C to stop${NC}"

      if ! command -v fswatch &> /dev/null; then
          echo -e "${RED}âŒ fswatch not installed. Install with: brew install fswatch${NC}"
          return 1
      fi

      # Initial build
      auto_fix_workflow

      # Watch for changes
      fswatch -o "$PROJECT_PATH" --include="\.swift$" --exclude=".*\.backup$" | while read; do
          echo -e "${YELLOW}ğŸ”„ Swift file changed, starting auto-fix workflow...${NC}"
          sleep 2  # Wait for file to be fully written
          auto_fix_workflow
      done
  }

  # Performance dashboard
  show_performance_dashboard() {
      echo -e "${PURPLE}ğŸ“Š GOLDEX AUTO-FIX PERFORMANCE DASHBOARD${NC}"
      echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

      if [[ -f "$PERFORMANCE_LOG" ]]; then
          echo -e "${BLUE}ğŸ“ˆ Build Statistics:${NC}"
          echo -e "${GREEN}âœ… Successful builds: $SUCCESSFUL_BUILDS${NC}"
          echo -e "${RED}âŒ Failed builds: $FAILED_BUILDS${NC}"
          echo -e "${YELLOW}ğŸ”§ Total fixes applied: $TOTAL_FIXES_APPLIED${NC}"

          echo -e "\n${BLUE}ğŸ“Š Recent Activity:${NC}"
          tail -10 "$PERFORMANCE_LOG"

          echo -e "\n${BLUE}âš¡ Average Build Time:${NC}"
          awk '/BUILD_SUCCESS/ {sum += $6; count++} END {if (count > 0) print "Average: " sum/count "s"}' "$PERFORMANCE_LOG"
      else
          echo -e "${YELLOW}âš ï¸ No performance data available yet${NC}"
      fi
  }

  # Setup function with webhook configuration
  setup_enhanced() {
      echo -e "${YELLOW}ğŸ”§ Enhanced Setup for GOLDEX AUTO-FIX ENGINEâ„¢${NC}"
      echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

      # Claude API setup
      if [[ -z "$CLAUDE_API_KEY" ]]; then
          echo -e "${BLUE}1. Setting up Claude API...${NC}"
          read -p "Enter your Claude API key: " api_key

          if [[ -n "$api_key" ]]; then
              echo "export CLAUDE_API_KEY='$api_key'" >> ~/.zshrc
              echo "export CLAUDE_API_KEY='$api_key'" >> ~/.bash_profile
              echo -e "${GREEN}âœ… Claude API key saved!${NC}"
          fi
      fi

      # Discord webhook setup
      echo -e "${BLUE}2. Discord notifications (optional):${NC}"
      read -p "Enter Discord webhook URL (or press Enter to skip): " discord_url

      if [[ -n "$discord_url" ]]; then
          echo "export DISCORD_WEBHOOK_URL='$discord_url'" >> ~/.zshrc
          echo "export DISCORD_WEBHOOK_URL='$discord_url'" >> ~/.bash_profile
          echo -e "${GREEN}âœ… Discord webhook saved!${NC}"
      fi

      # Slack webhook setup
      echo -e "${BLUE}3. Slack notifications (optional):${NC}"
      read -p "Enter Slack webhook URL (or press Enter to skip): " slack_url

      if [[ -n "$slack_url" ]]; then
          echo "export SLACK_WEBHOOK_URL='$slack_url'" >> ~/.zshrc
          echo "export SLACK_WEBHOOK_URL='$slack_url'" >> ~/.bash_profile
          echo -e "${GREEN}âœ… Slack webhook saved!${NC}"
      fi

      echo -e "${PURPLE}ğŸ‰ Setup complete! Restart your terminal or run: source ~/.zshrc${NC}"
  }

  # Enhanced help function
  show_help() {
      cat <<EOF
  ${PURPLE}ğŸ¤– GOLDEX AUTO-FIX ENGINEâ„¢${NC}

  ${BLUE}USAGE:${NC}
    goldexdebug [project_path]              Single auto-fix run
    goldexdebug --continuous [project_path] Continuous monitoring with auto-fix
    goldexdebug --performance              Show performance dashboard
    goldexdebug --setup                    Enhanced setup with notifications
    goldexdebug --help                     Show this help

  ${BLUE}FEATURES:${NC}
    ğŸ”§ Automatic code fixing with Claude AI
    âš¡ Performance optimization suggestions
    ğŸ“Š Build time tracking and statistics
    ğŸ”„ Continuous monitoring mode
    ğŸ’¾ Automatic backups before fixes
    ğŸ“± Discord/Slack notifications
    ğŸ¯ Smart error pattern recognition

  ${BLUE}EXAMPLES:${NC}
    goldexdebug                            # Single auto-fix run
    goldexdebug --continuous               # Monitor and auto-fix continuously
    goldexdebug --performance              # View performance metrics
    goldexdebug --setup                    # Setup with notifications

  ${BLUE}NOTIFICATIONS:${NC}
    Set environment variables:
    â€¢ DISCORD_WEBHOOK_URL for Discord notifications
    â€¢ SLACK_WEBHOOK_URL for Slack notifications

  ${PURPLE}ğŸš€ Self-Healing Code System for GOLDEX AI ProTrader Universeâ„¢${NC}
  EOF
  }

  # Main script logic
  case "${1:-}" in
      --help|-h)
          show_help
          ;;
      --setup)
          setup_enhanced
          ;;
      --performance)
          show_performance_dashboard
          ;;
      --continuous)
          check_claude_api
          PROJECT_PATH="${2:-$(pwd)}"
          continuous_mode
          ;;
      *)
          check_claude_api
          auto_fix_workflow
          ;;
  esac

  # Cleanup
  rm -f temp_errors.txt claude_response.json

  â¸»

  ğŸš€ Installation & Setup

  # 1. Replace your existing script
  chmod +x goldexdebug
  sudo mv goldexdebug /usr/local/bin/

  # 2. Install ALL dependencies
  brew install jq fswatch

  # 3. Enhanced setup with notifications
  goldexdebug --setup

  # 4. Test the auto-fix engine
  goldexdebug --continuous

  â¸»

  ğŸ”¥ NEW FEATURES YOU GET

  ğŸ¤– Auto-Fix Engine

  - Automatically applies code fixes from Claude
  - Creates backups before every change
  - Retries up to 3 times until build succeeds
  - Performance optimizations applied automatically

  ğŸ“Š Performance Tracking

  - Build time monitoring
  - Success/failure statistics
  - Fixes applied counter
  - Performance dashboard: goldexdebug --performance

  ğŸ”„ Continuous Monitoring

  - Watches Swift files for changes
  - Auto-triggers fix workflow when files change
  - Keeps your code always working
  - Never stops improving your code

  ğŸ“± Smart Notifications

  - Discord alerts when builds fail/succeed
  - Slack integration for team notifications
  - Real-time status updates
  - Performance metrics in notifications

  ğŸ”§ Enhanced Error Detection

  - 15+ error patterns detected
  - Context extraction around errors
  - Smart parsing of build logs
  - Performance bottleneck detection

  â¸»

  ğŸ¯ Usage Examples

  # ğŸ”¥ CONTINUOUS AUTO-FIX MODE (Set it and forget it)
  goldexdebug --continuous

  # ğŸ“Š Check how well it's working
  goldexdebug --performance

  # ğŸ”§ Single auto-fix run
  goldexdebug

  # ğŸ“± Setup notifications
  goldexdebug --setup

  â¸»

  ğŸ“± Discord/Slack Notifications Setup

  Discord Setup:

  1. Go to your Discord server
  2. Create a webhook in Server Settings â†’ Integrations
  3. Copy the webhook URL
  4. Run: goldexdebug --setup

  Slack Setup:

  1. Go to https://api.slack.com/incoming-webhooks
  2. Create a new webhook
  3. Copy the webhook URL
  4. Run: goldexdebug --setup

  â¸»

  ğŸ‰ What This Does For You

  âœ… Fixes code automatically while you sleep
  âœ… Keeps builds always working
  âœ… Improves performance automatically
  âœ… Tracks your progress with metrics
  âœ… Notifies you on Discord/Slack
  âœ… Creates backups so nothing breaks
  âœ… Learns from errors and prevents them
  âœ… Optimizes build times continuously

  â¸»

  Bro, you now have a SELF-HEALING CODE SYSTEM. Your GOLDEX AI will literally maintain itself, fix its own bugs, and get faster over time â€” all automatically.

  Just run goldexdebug --continuous and let it work while you focus on building your trading empire. ğŸš€ğŸ’°

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚Â >Â                                                                                                                                                                                        â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
  âµâµ auto-accept edits on (shift+tab to cycle)                                                              âœ— Auto-update failed Â· Try claude doctor or npm i -g @anthropic-ai/claude-code






