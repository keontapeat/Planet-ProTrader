//+------------------------------------------------------------------+
//|                                    GOLDEX_AI_ULTRA_AGGRESSIVE.mq5 |
//|                                  Copyright 2024, GOLDEX AI Team |
//|                                             https://goldexai.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, GOLDEX AI Keonta"
#property link      "https://goldexai.com"
#property version   "9.00"
#property strict

#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\AccountInfo.mqh>

CTrade trade;
CPositionInfo position;
CAccountInfo account;

//--- Trade Frequency Enum
enum ENUM_TRADE_FREQUENCY
{
   FREQ_EVERY_30_SECONDS = 30,
   FREQ_EVERY_1_MINUTE = 60,
   FREQ_EVERY_2_MINUTES = 120,
   FREQ_EVERY_5_MINUTES = 300,
   FREQ_EVERY_10_MINUTES = 600,
   FREQ_EVERY_15_MINUTES = 900,
   FREQ_EVERY_30_MINUTES = 1800,
   FREQ_EVERY_1_HOUR = 3600,
   FREQ_EVERY_2_HOURS = 7200,
   FREQ_CUSTOM = 0
};

//--- Input Parameters (Set to your preferred defaults)
input group "=== TRADE FREQUENCY CONTROL ==="
input ENUM_TRADE_FREQUENCY TradeFrequency = FREQ_EVERY_5_MINUTES;
input int CustomFrequencySeconds = 300; // Custom frequency in seconds
input bool EnableForceTrading = true; // Force trades at set intervals
input bool EnableClockwiseTrading = true; // 24/7 trading
input int MaxTradesPerHour = 12; // Maximum trades per hour
input int MaxTradesPerDay = 288; // Maximum trades per day
input bool EnableProgressiveRisk = true; // Increase risk after losses

input group "=== FLIP MODE SETTINGS ==="
input ENUM_TIMEFRAMES FlipTimeframe = PERIOD_M1;
input double FlipRiskPercent = 5.0;
input double FlipTargetPercent = 10.0;
input bool EnableFlipMode = true;
input bool EnableScalpMode = true;
input bool EnableAggressiveMode = true;

input group "=== RISK MANAGEMENT ==="
input double RiskPercentage = 8.0;
input double MaxRiskPercentage = 8.0;
input double StopLossPoints = 35.0;
input double TakeProfitPoints = 550.0;
input double TrailingStopPoints = 0.0;

input group "=== TRADING SETTINGS ==="
input bool EnableAutoTrading = true;
input bool EnableNotifications = true;
input bool EnableSoundAlerts = false;
input int MagicNumber = 123456;
input string TradeComment = "GOLDEX_AI_FLIP";

input group "=== AI ENHANCEMENT ==="
input bool EnableAILearning = true;
input bool EnableSmartEntry = true;
input bool EnableDynamicSizing = true;
input bool EnableMultiTimeframe = true;

input group "=== ULTRA AGGRESSIVE MODE ==="
input bool EnableUltraAggressive = true;
input int MaxSimultaneousPositions = 5;
input double ScalpProfitPoints = 10.0;
input double QuickExitPoints = 5.0;
input bool EnableInstantScalping = true;
input bool EnableHedging = true;
input bool EnableMartingale = false;
input double MartingaleMultiplier = 1.5;

input group "=== PROGRESSIVE PROFIT SYSTEM ==="
input bool EnableProgressiveProfit = true;
input double ProfitMultiplier = 2.0; // Multiply profit target after wins
input int WinStreakForBonus = 5; // Win streak needed for 20x profit
input double BonusMultiplier = 20.0; // 20x profit on win streak
input bool EnableLossRecovery = true; // Aggressive recovery after losses

//--- Global Variables
double AccountBalance = 0.0;
double InitialBalance = 0.0;
double CurrentDrawdown = 0.0;
double MaxDrawdown = 0.0;
double DailyTarget = 0.0;
double WeeklyTarget = 0.0;
int TotalTrades = 0;
int WinningTrades = 0;
int ConsecutiveWins = 0;
int ConsecutiveLosses = 0;
double WinRate = 0.0;
bool FlipModeActive = false;
datetime LastTradeTime = 0;
datetime LastForceTradeTime = 0;
double LastPrice = 0.0;
string Symbol = "";
double CurrentMultiplier = 1.0;
bool AlwaysInTrade = false;
int TradesThisHour = 0;
int TradesThisDay = 0;
datetime CurrentHour = 0;
datetime CurrentDay = 0;
int TradeFrequencySeconds = 300;

//--- Arrays for multiple position tracking
ulong PositionTickets[];
datetime PositionOpenTimes[];
double PositionProfits[];
int ActivePositions = 0;

//--- Indicator Handles
int RSI_Handle;
int MACD_Handle;
int MA_Handle_5;
int MA_Handle_20;
int MA_Handle_50;
int ATR_Handle;
int BB_Handle;
int MOM_Handle;

//--- Enums
enum ENUM_ULTRA_MODE
{
   ULTRA_CONSERVATIVE,
   ULTRA_MODERATE,
   ULTRA_AGGRESSIVE,
   ULTRA_INSANE,
   ULTRA_SCALP_MASTER
};

enum ENUM_SIGNAL_TYPE
{
   SIGNAL_NONE,
   SIGNAL_BUY,
   SIGNAL_SELL,
   SIGNAL_CLOSE_BUY,
   SIGNAL_CLOSE_SELL,
   SIGNAL_SCALP_BUY,
   SIGNAL_SCALP_SELL,
   SIGNAL_HEDGE_BUY,
   SIGNAL_HEDGE_SELL,
   SIGNAL_FORCE_BUY,
   SIGNAL_FORCE_SELL,
   SIGNAL_RECOVERY_BUY,
   SIGNAL_RECOVERY_SELL
};

//--- Structures
struct UltraAggressiveSignal
{
   ENUM_SIGNAL_TYPE direction;
   double entryPrice;
   double stopLoss;
   double takeProfit;
   double lotSize;
   double confidence;
   double urgency;
   bool isScalp;
   bool isHedge;
   bool isForced;
   bool isRecovery;
   int timeframe;
   double expectedProfit;
   double riskReward;
   string signalReason;
   datetime signalTime;
};

struct TradingState
{
   bool inUptrend;
   bool inDowntrend;
   bool inRange;
   double volatility;
   double momentum;
   double strength;
   double opportunity;
};

struct TradingStats
{
   int totalTrades;
   int winningTrades;
   int losingTrades;
   double totalProfit;
   double totalLoss;
   double largestWin;
   double largestLoss;
   double averageWin;
   double averageLoss;
   double profitFactor;
   double winRate;
   int maxConsecutiveWins;
   int maxConsecutiveLosses;
   double maxDrawdown;
   double recovery;
};

//--- Global Objects
UltraAggressiveSignal currentSignal;
TradingState marketState;
TradingStats stats;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   Symbol = _Symbol;
   AccountBalance = account.Balance();
   InitialBalance = AccountBalance;
   
   // Set trade frequency
   if(TradeFrequency == FREQ_CUSTOM)
   {
      TradeFrequencySeconds = CustomFrequencySeconds;
   }
   else
   {
      TradeFrequencySeconds = (int)TradeFrequency;
   }
   
   // Initialize time tracking
   CurrentHour = TimeCurrent() / 3600 * 3600;
   CurrentDay = TimeCurrent() / 86400 * 86400;
   
   // Initialize indicator handles
   RSI_Handle = iRSI(Symbol, PERIOD_M15, 14, PRICE_CLOSE);
   MACD_Handle = iMACD(Symbol, PERIOD_M15, 12, 26, 9, PRICE_CLOSE);
   MA_Handle_5 = iMA(Symbol, PERIOD_M15, 5, 0, MODE_EMA, PRICE_CLOSE);
   MA_Handle_20 = iMA(Symbol, PERIOD_M15, 20, 0, MODE_EMA, PRICE_CLOSE);
   MA_Handle_50 = iMA(Symbol, PERIOD_M15, 50, 0, MODE_EMA, PRICE_CLOSE);
   ATR_Handle = iATR(Symbol, PERIOD_M15, 14);
   BB_Handle = iBands(Symbol, PERIOD_M5, 20, 0, 2, PRICE_CLOSE);
   MOM_Handle = iMomentum(Symbol, PERIOD_M1, 10, PRICE_CLOSE);
   
   // Check if all handles are valid
   if(RSI_Handle == INVALID_HANDLE || MACD_Handle == INVALID_HANDLE || 
      MA_Handle_5 == INVALID_HANDLE || MA_Handle_20 == INVALID_HANDLE || 
      MA_Handle_50 == INVALID_HANDLE || ATR_Handle == INVALID_HANDLE ||
      BB_Handle == INVALID_HANDLE || MOM_Handle == INVALID_HANDLE)
   {
      Print("Error creating indicator handles");
      return(INIT_FAILED);
   }
   
   // Initialize arrays
   ArrayResize(PositionTickets, MaxSimultaneousPositions);
   ArrayResize(PositionOpenTimes, MaxSimultaneousPositions);
   ArrayResize(PositionProfits, MaxSimultaneousPositions);
   
   // Initialize stats
   InitializeStats();
   
   // Set up ultra aggressive mode
   if(EnableUltraAggressive)
   {
      SetupUltraAggressiveMode();
   }
   
   // Set up flip mode targets
   if(EnableFlipMode)
   {
      SetupFlipModeTargets();
   }
   
   // Enable always in trade mode
   AlwaysInTrade = EnableUltraAggressive;
   
   Print("🚀 GOLDEX AI ULTRA AGGRESSIVE EA v5.0 Initialized");
   Print("💰 Account Balance: $", AccountBalance);
   Print("🎯 Target: $1,000 → $100,000");
   Print("⚡ Trade Frequency: Every ", TradeFrequencySeconds, " seconds");
   Print("🔥 Max Trades/Hour: ", MaxTradesPerHour);
   Print("📅 Max Trades/Day: ", MaxTradesPerDay);
   Print("🎲 Progressive Profit: ", EnableProgressiveProfit ? "ENABLED" : "DISABLED");
   Print("🔄 24/7 Trading: ", EnableClockwiseTrading ? "ENABLED" : "DISABLED");
   Print("💨 Instant Scalping: ", EnableInstantScalping ? "ENABLED" : "DISABLED");
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                               |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // Release indicator handles
   if(RSI_Handle != INVALID_HANDLE) IndicatorRelease(RSI_Handle);
   if(MACD_Handle != INVALID_HANDLE) IndicatorRelease(MACD_Handle);
   if(MA_Handle_5 != INVALID_HANDLE) IndicatorRelease(MA_Handle_5);
   if(MA_Handle_20 != INVALID_HANDLE) IndicatorRelease(MA_Handle_20);
   if(MA_Handle_50 != INVALID_HANDLE) IndicatorRelease(MA_Handle_50);
   if(ATR_Handle != INVALID_HANDLE) IndicatorRelease(ATR_Handle);
   if(BB_Handle != INVALID_HANDLE) IndicatorRelease(BB_Handle);
   if(MOM_Handle != INVALID_HANDLE) IndicatorRelease(MOM_Handle);
   
   Print("GOLDEX AI ULTRA AGGRESSIVE EA Deinitialized. Reason: ", reason);
   SaveUltraAggressiveStats();
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!EnableAutoTrading) return;
   
   // Update time tracking
   UpdateTimeTracking();
   
   // Update account and market state
   UpdateAccountInfo();
   UpdateMarketState();
   
   // Check for forced trading at set intervals
   if(EnableForceTrading && ShouldForceNewTrade())
   {
      ExecuteForceTrading();
   }
   
   // Ultra aggressive trading logic
   if(EnableUltraAggressive)
   {
      ExecuteUltraAggressiveStrategy();
   }
   
   // Regular flip mode trading
   if(EnableFlipMode)
   {
      ExecuteFlipModeStrategy();
   }
   
   // Scalping logic
   if(EnableScalpMode || EnableInstantScalping)
   {
      ExecuteScalpingStrategy();
   }
   
   // Loss recovery system
   if(EnableLossRecovery && ConsecutiveLosses >= 3)
   {
      ExecuteLossRecoveryStrategy();
   }
   
   // Manage all positions
   ManageAllPositions();
   
   // Ensure always in trade if enabled
   if(AlwaysInTrade && ActivePositions == 0 && CanTrade())
   {
      ForceTradeEntry();
   }
   
   // Update position tracking
   UpdatePositionTracking();
   
   // Update statistics
   UpdateStats();
}

//+------------------------------------------------------------------+
//| Update Time Tracking                                            |
//+------------------------------------------------------------------+
void UpdateTimeTracking()
{
   datetime currentTime = TimeCurrent();
   datetime newHour = currentTime / 3600 * 3600;
   datetime newDay = currentTime / 86400 * 86400;
   
   // Reset hourly counter
   if(newHour != CurrentHour)
   {
      CurrentHour = newHour;
      TradesThisHour = 0;
   }
   
   // Reset daily counter
   if(newDay != CurrentDay)
   {
      CurrentDay = newDay;
      TradesThisDay = 0;
   }
}

//+------------------------------------------------------------------+
//| Should Force New Trade                                          |
//+------------------------------------------------------------------+
bool ShouldForceNewTrade()
{
   // Check if enough time has passed since last trade
   if(TimeCurrent() - LastForceTradeTime < TradeFrequencySeconds)
      return false;
   
   // Check trade limits
   if(!CanTrade())
      return false;
   
   // Check if we need to force a trade
   if(ActivePositions == 0)
      return true;
   
   // Force trade even with active positions for maximum aggression
   if(ActivePositions < MaxSimultaneousPositions)
      return true;
   
   return false;
}

//+------------------------------------------------------------------+
//| Can Trade                                                        |
//+------------------------------------------------------------------+
bool CanTrade()
{
   // Check hourly limit
   if(TradesThisHour >= MaxTradesPerHour)
      return false;
   
   // Check daily limit
   if(TradesThisDay >= MaxTradesPerDay)
      return false;
   
   // Check if 24/7 trading is enabled
   if(!EnableClockwiseTrading)
   {
      // Check market hours (example: 9 AM to 5 PM)
      MqlDateTime dt;
      TimeCurrent(dt);
      if(dt.hour < 9 || dt.hour > 17)
         return false;
   }
   
   // Check maximum drawdown
   if(CurrentDrawdown > MaxRiskPercentage)
      return false;
   
   return true;
}

//+------------------------------------------------------------------+
//| Execute Force Trading                                           |
//+------------------------------------------------------------------+
void ExecuteForceTrading()
{
   UltraAggressiveSignal forceSignal;
   forceSignal.isForced = true;
   forceSignal.confidence = 75.0;
   forceSignal.urgency = 90.0;
   forceSignal.signalTime = TimeCurrent();
   forceSignal.signalReason = "Force_Trade_" + IntegerToString(TradeFrequencySeconds) + "s";
   
   // Generate force signal based on current market conditions
   forceSignal = GenerateForceSignal();
   
   if(forceSignal.direction != SIGNAL_NONE)
   {
      ExecuteUltraSignal(forceSignal);
      LastForceTradeTime = TimeCurrent();
   }
}

//+------------------------------------------------------------------+
//| Generate Force Signal                                           |
//+------------------------------------------------------------------+
UltraAggressiveSignal GenerateForceSignal()
{
   UltraAggressiveSignal signal;
   signal.direction = SIGNAL_NONE;
   signal.isForced = true;
   signal.confidence = 70.0;
   signal.urgency = 85.0;
   signal.signalTime = TimeCurrent();
   signal.entryPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   
   // Get market indicators for force signal
   double ma20[], ma50[], rsi[], atr[];
   ArraySetAsSeries(ma20, true);
   ArraySetAsSeries(ma50, true);
   ArraySetAsSeries(rsi, true);
   ArraySetAsSeries(atr, true);
   
   if(CopyBuffer(MA_Handle_20, 0, 0, 3, ma20) > 0 && 
      CopyBuffer(MA_Handle_50, 0, 0, 3, ma50) > 0 && 
      CopyBuffer(RSI_Handle, 0, 0, 3, rsi) > 0 &&
      CopyBuffer(ATR_Handle, 0, 0, 3, atr) > 0)
   {
      double currentPrice = signal.entryPrice;
      
      // Force direction based on multiple factors
      double bullishScore = 0.0;
      double bearishScore = 0.0;
      
      // Trend bias
      if(currentPrice > ma20[0] && ma20[0] > ma50[0]) bullishScore += 30.0;
      if(currentPrice < ma20[0] && ma20[0] < ma50[0]) bearishScore += 30.0;
      
      // RSI bias
      if(rsi[0] < 50) bullishScore += 20.0;
      if(rsi[0] > 50) bearishScore += 20.0;
      
      // Volatility consideration
      if(atr[0] > 0) {
         bullishScore += 15.0;
         bearishScore += 15.0;
      }
      
      // Random factor to ensure trading
      int randomFactor = MathRand() % 100;
      if(randomFactor > 50) bullishScore += 25.0;
      else bearishScore += 25.0;
      
      // Determine direction
      if(bullishScore > bearishScore)
      {
         signal.direction = SIGNAL_FORCE_BUY;
         signal.confidence = bullishScore;
      }
      else
      {
         signal.direction = SIGNAL_FORCE_SELL;
         signal.confidence = bearishScore;
      }
      
      // Calculate stops and targets
      signal.stopLoss = CalculateForceStopLoss(signal.direction, currentPrice, atr[0]);
      signal.takeProfit = CalculateForceTakeProfit(signal.direction, currentPrice, atr[0]);
      signal.lotSize = CalculateAggressiveLotSize(signal.stopLoss, currentPrice, false);
      signal.riskReward = MathAbs(signal.takeProfit - signal.entryPrice) / MathAbs(signal.entryPrice - signal.stopLoss);
      signal.expectedProfit = signal.lotSize * MathAbs(signal.takeProfit - signal.entryPrice) * 100000;
      
      // Apply progressive profit system
      if(EnableProgressiveProfit)
      {
         ApplyProgressiveProfit(signal);
      }
   }
   
   return signal;
}

//+------------------------------------------------------------------+
//| Execute Loss Recovery Strategy                                  |
//+------------------------------------------------------------------+
void ExecuteLossRecoveryStrategy()
{
   if(ConsecutiveLosses < 3) return;
   
   UltraAggressiveSignal recoverySignal;
   recoverySignal.isRecovery = true;
   recoverySignal.confidence = 85.0;
   recoverySignal.urgency = 95.0;
   recoverySignal.signalTime = TimeCurrent();
   recoverySignal.signalReason = "Loss_Recovery_" + IntegerToString(ConsecutiveLosses);
   
   // Generate aggressive recovery signal
   recoverySignal = GenerateRecoverySignal();
   
   if(recoverySignal.direction != SIGNAL_NONE && ActivePositions < MaxSimultaneousPositions)
   {
      ExecuteUltraSignal(recoverySignal);
   }
}

//+------------------------------------------------------------------+
//| Generate Recovery Signal                                        |
//+------------------------------------------------------------------+
UltraAggressiveSignal GenerateRecoverySignal()
{
   UltraAggressiveSignal signal;
   signal.direction = SIGNAL_NONE;
   signal.isRecovery = true;
   signal.confidence = 80.0;
   signal.urgency = 90.0;
   signal.signalTime = TimeCurrent();
   signal.entryPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   
   // More aggressive recovery approach
   double currentPrice = signal.entryPrice;
   
   // Simple trend following for recovery
   double ma20[], ma50[];
   ArraySetAsSeries(ma20, true);
   ArraySetAsSeries(ma50, true);
   
   if(CopyBuffer(MA_Handle_20, 0, 0, 3, ma20) > 0 && 
      CopyBuffer(MA_Handle_50, 0, 0, 3, ma50) > 0)
   {
      if(currentPrice > ma20[0])
      {
         signal.direction = SIGNAL_RECOVERY_BUY;
      }
      else
      {
         signal.direction = SIGNAL_RECOVERY_SELL;
      }
      
      // Aggressive recovery parameters
      signal.stopLoss = CalculateRecoveryStopLoss(signal.direction, currentPrice);
      signal.takeProfit = CalculateRecoveryTakeProfit(signal.direction, currentPrice);
      signal.lotSize = CalculateRecoveryLotSize(signal.stopLoss, currentPrice);
      signal.riskReward = MathAbs(signal.takeProfit - signal.entryPrice) / MathAbs(signal.entryPrice - signal.stopLoss);
      signal.expectedProfit = signal.lotSize * MathAbs(signal.takeProfit - signal.entryPrice) * 100000;
   }
   
   return signal;
}

//+------------------------------------------------------------------+
//| Apply Progressive Profit System                                 |
//+------------------------------------------------------------------+
void ApplyProgressiveProfit(UltraAggressiveSignal &signal)
{
   if(!EnableProgressiveProfit) return;
   
   // Check for win streak bonus
   if(ConsecutiveWins >= WinStreakForBonus)
   {
      // Apply 20x profit multiplier
      double currentTarget = signal.takeProfit;
      double entryPrice = signal.entryPrice;
      double profitDistance = MathAbs(currentTarget - entryPrice);
      double newProfitDistance = profitDistance * BonusMultiplier;
      
      if(signal.direction == SIGNAL_FORCE_BUY || signal.direction == SIGNAL_BUY)
      {
         signal.takeProfit = entryPrice + newProfitDistance;
      }
      else
      {
         signal.takeProfit = entryPrice - newProfitDistance;
      }
      
      signal.signalReason += "_20X_BONUS";
      signal.expectedProfit *= BonusMultiplier;
      signal.confidence = 95.0;
      signal.urgency = 100.0;
   }
   else if(ConsecutiveWins >= 2)
   {
      // Apply regular profit multiplier
      double currentTarget = signal.takeProfit;
      double entryPrice = signal.entryPrice;
      double profitDistance = MathAbs(currentTarget - entryPrice);
      double newProfitDistance = profitDistance * ProfitMultiplier;
      
      if(signal.direction == SIGNAL_FORCE_BUY || signal.direction == SIGNAL_BUY)
      {
         signal.takeProfit = entryPrice + newProfitDistance;
      }
      else
      {
         signal.takeProfit = entryPrice - newProfitDistance;
      }
      
      signal.signalReason += "_PROGRESSIVE";
      signal.expectedProfit *= ProfitMultiplier;
   }
   
   // Apply progressive risk after losses
   if(EnableProgressiveRisk && ConsecutiveLosses >= 2)
   {
      signal.lotSize *= (1.0 + (ConsecutiveLosses * 0.5));
      signal.signalReason += "_RECOVERY";
   }
}

//+------------------------------------------------------------------+
//| Calculate Force Stop Loss                                       |
//+------------------------------------------------------------------+
double CalculateForceStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice, double atr)
{
   double stopLoss = atr * 1.5; // 1.5x ATR for force trades
   
   if(direction == SIGNAL_FORCE_BUY)
   {
      return entryPrice - stopLoss;
   }
   else
   {
      return entryPrice + stopLoss;
   }
}

//+------------------------------------------------------------------+
//| Calculate Force Take Profit                                     |
//+------------------------------------------------------------------+
double CalculateForceTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice, double atr)
{
   double takeProfit = atr * 3.0; // 3x ATR for force trades
   
   if(direction == SIGNAL_FORCE_BUY)
   {
      return entryPrice + takeProfit;
   }
   else
   {
      return entryPrice - takeProfit;
   }
}

//+------------------------------------------------------------------+
//| Calculate Recovery Stop Loss                                    |
//+------------------------------------------------------------------+
double CalculateRecoveryStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double stopLossPoints = 25.0; // Tight stop for recovery
   
   if(direction == SIGNAL_RECOVERY_BUY)
   {
      return entryPrice - (stopLossPoints * point);
   }
   else
   {
      return entryPrice + (stopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Recovery Take Profit                                  |
//+------------------------------------------------------------------+
double CalculateRecoveryTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double takeProfitPoints = 100.0; // Larger target for recovery
   
   if(direction == SIGNAL_RECOVERY_BUY)
   {
      return entryPrice + (takeProfitPoints * point);
   }
   else
   {
      return entryPrice - (takeProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Recovery Lot Size                                     |
//+------------------------------------------------------------------+
double CalculateRecoveryLotSize(double stopLoss, double entryPrice)
{
   double balance = account.Balance();
   double riskPercent = MathMin(15.0, RiskPercentage * (1.0 + ConsecutiveLosses * 0.5));
   double riskAmount = balance * (riskPercent / 100.0);
   
   double stopLossPoints = MathAbs(entryPrice - stopLoss);
   double tickValue = SymbolInfoDouble(Symbol, SYMBOL_TRADE_TICK_VALUE);
   double lotSize = riskAmount / (stopLossPoints * tickValue * 100000);
   
   // Normalize lot size
   double minLot = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_STEP);
   
   lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
   lotSize = MathRound(lotSize / lotStep) * lotStep;
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Setup Ultra Aggressive Mode                                     |
//+------------------------------------------------------------------+
void SetupUltraAggressiveMode()
{
   // Configure for maximum aggression
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetDeviationInPoints(10);
   trade.SetTypeFilling(ORDER_FILLING_IOC);
   
   Print("🔥 Ultra Aggressive Mode Configured");
   Print("⚡ Max Positions: ", MaxSimultaneousPositions);
   Print("💨 Scalp Profit: ", ScalpProfitPoints, " points");
   Print("🎯 Quick Exit: ", QuickExitPoints, " points");
   Print("⏰ Trade Frequency: ", TradeFrequencySeconds, " seconds");
   Print("🎰 Progressive Profit: ", EnableProgressiveProfit ? "ON" : "OFF");
}

//+------------------------------------------------------------------+
//| Execute Ultra Aggressive Strategy                               |
//+------------------------------------------------------------------+
void ExecuteUltraAggressiveStrategy()
{
   // Generate multiple signals simultaneously
   UltraAggressiveSignal signals[];
   int signalCount = GenerateMultipleSignals(signals);
   
   // Execute up to max simultaneous positions
   for(int i = 0; i < signalCount && ActivePositions < MaxSimultaneousPositions; i++)
   {
      if(signals[i].confidence > 60.0 && CanTrade())
      {
         ExecuteUltraSignal(signals[i]);
      }
   }
   
   // Check for immediate scalping opportunities
   if(EnableInstantScalping)
   {
      CheckInstantScalpingOpportunity();
   }
   
   // Hedging logic
   if(EnableHedging && ActivePositions > 0)
   {
      CheckHedgingOpportunity();
   }
}

//+------------------------------------------------------------------+
//| Generate Multiple Signals                                        |
//+------------------------------------------------------------------+
int GenerateMultipleSignals(UltraAggressiveSignal &signals[])
{
   ArrayResize(signals, 10);
   int count = 0;
   
   // M1 Scalping Signal
   UltraAggressiveSignal m1Signal = GenerateTimeframeSignal(PERIOD_M1, true);
   if(m1Signal.direction != SIGNAL_NONE)
   {
      signals[count] = m1Signal;
      count++;
   }
   
   // M5 Quick Signal
   UltraAggressiveSignal m5Signal = GenerateTimeframeSignal(PERIOD_M5, false);
   if(m5Signal.direction != SIGNAL_NONE)
   {
      signals[count] = m5Signal;
      count++;
   }
   
   // M15 Trend Signal
   UltraAggressiveSignal m15Signal = GenerateTimeframeSignal(PERIOD_M15, false);
   if(m15Signal.direction != SIGNAL_NONE)
   {
      signals[count] = m15Signal;
      count++;
   }
   
   // Volatility Breakout Signal
   UltraAggressiveSignal volatilitySignal = GenerateVolatilitySignal();
   if(volatilitySignal.direction != SIGNAL_NONE)
   {
      signals[count] = volatilitySignal;
      count++;
   }
   
   // Momentum Signal
   UltraAggressiveSignal momentumSignal = GenerateMomentumSignal();
   if(momentumSignal.direction != SIGNAL_NONE)
   {
      signals[count] = momentumSignal;
      count++;
   }
   
   return count;
}

//+------------------------------------------------------------------+
//| Generate Timeframe Signal                                        |
//+------------------------------------------------------------------+
UltraAggressiveSignal GenerateTimeframeSignal(ENUM_TIMEFRAMES timeframe, bool isScalp)
{
   UltraAggressiveSignal signal;
   signal.direction = SIGNAL_NONE;
   signal.confidence = 0.0;
   signal.isScalp = isScalp;
   signal.timeframe = timeframe;
   signal.signalTime = TimeCurrent();
   
   double currentPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   
   // Get indicator values using handles
   double rsiValue[];
   double macdMain[], macdSignal[];
   double ma5[], ma20[], ma50[];
   
   ArraySetAsSeries(rsiValue, true);
   ArraySetAsSeries(macdMain, true);
   ArraySetAsSeries(macdSignal, true);
   ArraySetAsSeries(ma5, true);
   ArraySetAsSeries(ma20, true);
   ArraySetAsSeries(ma50, true);
   
   // Copy indicator data
   if(CopyBuffer(RSI_Handle, 0, 0, 3, rsiValue) <= 0) return signal;
   if(CopyBuffer(MACD_Handle, 0, 0, 3, macdMain) <= 0) return signal;
   if(CopyBuffer(MACD_Handle, 1, 0, 3, macdSignal) <= 0) return signal;
   if(CopyBuffer(MA_Handle_5, 0, 0, 3, ma5) <= 0) return signal;
   if(CopyBuffer(MA_Handle_20, 0, 0, 3, ma20) <= 0) return signal;
   if(CopyBuffer(MA_Handle_50, 0, 0, 3, ma50) <= 0) return signal;
   
   double rsi = rsiValue[0];
   
   // Signal Logic
   double bullishScore = 0.0;
   double bearishScore = 0.0;
   
   // RSI scoring
   if(rsi < 30) bullishScore += 30.0;
   if(rsi > 70) bearishScore += 30.0;
   if(rsi > 50 && rsi < 70) bullishScore += 10.0;
   if(rsi < 50 && rsi > 30) bearishScore += 10.0;
   
   // MA scoring
   if(currentPrice > ma5[0] && ma5[0] > ma20[0] && ma20[0] > ma50[0]) bullishScore += 25.0;
   if(currentPrice < ma5[0] && ma5[0] < ma20[0] && ma20[0] < ma50[0]) bearishScore += 25.0;
   
   // MACD scoring
   if(macdMain[0] > macdSignal[0] && macdMain[1] <= macdSignal[1]) bullishScore += 20.0;
   if(macdMain[0] < macdSignal[0] && macdMain[1] >= macdSignal[1]) bearishScore += 20.0;
   
   // Price action scoring
   double priceChange = (currentPrice - ma20[0]) / ma20[0] * 100;
   if(priceChange > 0.1) bullishScore += 15.0;
   if(priceChange < -0.1) bearishScore += 15.0;
   
   // Determine signal
   if(bullishScore > bearishScore && bullishScore >= 50.0)
   {
      signal.direction = isScalp ? SIGNAL_SCALP_BUY : SIGNAL_BUY;
      signal.confidence = bullishScore;
      signal.signalReason = "Bullish " + EnumToString(timeframe) + " signal";
   }
   else if(bearishScore > bullishScore && bearishScore >= 50.0)
   {
      signal.direction = isScalp ? SIGNAL_SCALP_SELL : SIGNAL_SELL;
      signal.confidence = bearishScore;
      signal.signalReason = "Bearish " + EnumToString(timeframe) + " signal";
   }
   
   // Set signal parameters
   if(signal.direction != SIGNAL_NONE)
   {
      signal.entryPrice = currentPrice;
      signal.urgency = isScalp ? 95.0 : 75.0;
      
      if(isScalp)
      {
         signal.stopLoss = CalculateScalpStopLoss(signal.direction, currentPrice);
         signal.takeProfit = CalculateScalpTakeProfit(signal.direction, currentPrice);
      }
      else
      {
         signal.stopLoss = CalculateStopLoss(signal.direction, currentPrice);
         signal.takeProfit = CalculateTakeProfit(signal.direction, currentPrice);
      }
      
      signal.lotSize = CalculateAggressiveLotSize(signal.stopLoss, currentPrice, isScalp);
      signal.riskReward = MathAbs(signal.takeProfit - signal.entryPrice) / MathAbs(signal.entryPrice - signal.stopLoss);
      signal.expectedProfit = signal.lotSize * MathAbs(signal.takeProfit - signal.entryPrice) * 100000;
      
      // Apply progressive profit system
      if(EnableProgressiveProfit)
      {
         ApplyProgressiveProfit(signal);
      }
   }
   
   return signal;
}

//+------------------------------------------------------------------+
//| Generate Volatility Signal                                       |
//+------------------------------------------------------------------+
UltraAggressiveSignal GenerateVolatilitySignal()
{
   UltraAggressiveSignal signal;
   signal.direction = SIGNAL_NONE;
   signal.confidence = 0.0;
   signal.signalReason = "Volatility Breakout";
   signal.signalTime = TimeCurrent();
   
   double currentPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   
   // Get ATR and Bollinger Bands values
   double atrValue[];
   double bbUpper[], bbLower[];
   
   ArraySetAsSeries(atrValue, true);
   ArraySetAsSeries(bbUpper, true);
   ArraySetAsSeries(bbLower, true);
   
   if(CopyBuffer(ATR_Handle, 0, 0, 3, atrValue) <= 0) return signal;
   if(CopyBuffer(BB_Handle, 1, 0, 3, bbUpper) <= 0) return signal;
   if(CopyBuffer(BB_Handle, 2, 0, 3, bbLower) <= 0) return signal;
   
   double atr = atrValue[0];
   
   // Volatility breakout logic
   if(currentPrice > bbUpper[0])
   {
      signal.direction = SIGNAL_BUY;
      signal.confidence = 80.0;
      signal.urgency = 90.0;
   }
   else if(currentPrice < bbLower[0])
   {
      signal.direction = SIGNAL_SELL;
      signal.confidence = 80.0;
      signal.urgency = 90.0;
   }
   
   if(signal.direction != SIGNAL_NONE)
   {
      signal.entryPrice = currentPrice;
      signal.stopLoss = CalculateVolatilityStopLoss(signal.direction, currentPrice, atr);
      signal.takeProfit = CalculateVolatilityTakeProfit(signal.direction, currentPrice, atr);
      signal.lotSize = CalculateAggressiveLotSize(signal.stopLoss, currentPrice, false);
      signal.riskReward = MathAbs(signal.takeProfit - signal.entryPrice) / MathAbs(signal.entryPrice - signal.stopLoss);
      signal.expectedProfit = signal.lotSize * MathAbs(signal.takeProfit - signal.entryPrice) * 100000;
      
      // Apply progressive profit system
      if(EnableProgressiveProfit)
      {
         ApplyProgressiveProfit(signal);
      }
   }
   
   return signal;
}

//+------------------------------------------------------------------+
//| Generate Momentum Signal                                         |
//+------------------------------------------------------------------+
UltraAggressiveSignal GenerateMomentumSignal()
{
   UltraAggressiveSignal signal;
   signal.direction = SIGNAL_NONE;
   signal.confidence = 0.0;
   signal.signalReason = "Momentum Surge";
   signal.signalTime = TimeCurrent();
   
   double currentPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   
   // Get momentum values
   double momValue[];
   ArraySetAsSeries(momValue, true);
   
   if(CopyBuffer(MOM_Handle, 0, 0, 3, momValue) <= 0) return signal;
   
   double mom = momValue[0];
   
   // Get price data for ROC calculation
   double priceData[];
   ArraySetAsSeries(priceData, true);
   
   if(CopyClose(Symbol, PERIOD_M1, 0, 10, priceData) <= 0) return signal;
   
   // Price rate of change
   double priceROC = (priceData[0] - priceData[5]) / priceData[5] * 100;
   
   // Momentum surge detection
   if(mom > 100.05 && priceROC > 0.02)
   {
      signal.direction = SIGNAL_BUY;
      signal.confidence = 85.0;
      signal.urgency = 95.0;
   }
   else if(mom < 99.95 && priceROC < -0.02)
   {
      signal.direction = SIGNAL_SELL;
      signal.confidence = 85.0;
      signal.urgency = 95.0;
   }
   
   if(signal.direction != SIGNAL_NONE)
   {
      signal.entryPrice = currentPrice;
      signal.stopLoss = CalculateMomentumStopLoss(signal.direction, currentPrice);
      signal.takeProfit = CalculateMomentumTakeProfit(signal.direction, currentPrice);
      signal.lotSize = CalculateAggressiveLotSize(signal.stopLoss, currentPrice, false);
      signal.riskReward = MathAbs(signal.takeProfit - signal.entryPrice) / MathAbs(signal.entryPrice - signal.stopLoss);
      signal.expectedProfit = signal.lotSize * MathAbs(signal.takeProfit - signal.entryPrice) * 100000;
      
      // Apply progressive profit system
      if(EnableProgressiveProfit)
      {
         ApplyProgressiveProfit(signal);
      }
   }
   
   return signal;
}

//+------------------------------------------------------------------+
//| Execute Ultra Signal                                             |
//+------------------------------------------------------------------+
void ExecuteUltraSignal(UltraAggressiveSignal &signal)
{
   if(!CanTrade()) return;
   
   bool success = false;
   ulong ticket = 0;
   
   // Execute based on signal type
   switch(signal.direction)
   {
      case SIGNAL_BUY:
      case SIGNAL_SCALP_BUY:
      case SIGNAL_FORCE_BUY:
      case SIGNAL_RECOVERY_BUY:
         success = trade.Buy(signal.lotSize, Symbol, signal.entryPrice, signal.stopLoss, signal.takeProfit, TradeComment + "_" + signal.signalReason);
         ticket = trade.ResultOrder();
         break;
         
      case SIGNAL_SELL:
      case SIGNAL_SCALP_SELL:
      case SIGNAL_FORCE_SELL:
      case SIGNAL_RECOVERY_SELL:
         success = trade.Sell(signal.lotSize, Symbol, signal.entryPrice, signal.stopLoss, signal.takeProfit, TradeComment + "_" + signal.signalReason);
         ticket = trade.ResultOrder();
         break;
   }
   
   if(success && ticket > 0)
   {
      // Add to position tracking
      if(ActivePositions < MaxSimultaneousPositions)
      {
         PositionTickets[ActivePositions] = ticket;
         PositionOpenTimes[ActivePositions] = TimeCurrent();
         PositionProfits[ActivePositions] = 0.0;
         ActivePositions++;
      }
      
      TotalTrades++;
      TradesThisHour++;
      TradesThisDay++;
      LastTradeTime = TimeCurrent();
      
      // Log the trade
      LogUltraAggressiveTrade(signal, ticket);
      
      // Send notification
      if(EnableNotifications)
      {
         SendNotification(CreateUltraNotification(signal));
      }
      
      // Play sound
      if(EnableSoundAlerts)
      {
         PlaySound("alert.wav");
      }
   }
}

//+------------------------------------------------------------------+
//| Check Instant Scalping Opportunity                              |
//+------------------------------------------------------------------+
void CheckInstantScalpingOpportunity()
{
   if(!CanTrade()) return;
   
   double currentPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   double bidPrice = SymbolInfoDouble(Symbol, SYMBOL_BID);
   double spread = currentPrice - bidPrice;
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   
   // Very quick scalping based on spread and micro movements
   static double lastScalpPrice = 0.0;
   static datetime lastScalpTime = 0;
   
   if(lastScalpPrice == 0.0)
   {
      lastScalpPrice = currentPrice;
      lastScalpTime = TimeCurrent();
      return;
   }
   
   double priceMove = MathAbs(currentPrice - lastScalpPrice);
   int timeDiff = (int)(TimeCurrent() - lastScalpTime);
   
   // Instant scalp conditions
   if(priceMove >= 3.0 * point && timeDiff >= 1)
   {
      UltraAggressiveSignal scalpSignal;
      scalpSignal.isScalp = true;
      scalpSignal.urgency = 99.0;
      scalpSignal.confidence = 70.0;
      scalpSignal.entryPrice = currentPrice;
      scalpSignal.signalReason = "Instant_Scalp";
      scalpSignal.signalTime = TimeCurrent();
      
      if(currentPrice > lastScalpPrice)
      {
         scalpSignal.direction = SIGNAL_SCALP_BUY;
      }
      else
      {
         scalpSignal.direction = SIGNAL_SCALP_SELL;
      }
      
      scalpSignal.stopLoss = CalculateInstantScalpStopLoss(scalpSignal.direction, currentPrice);
      scalpSignal.takeProfit = CalculateInstantScalpTakeProfit(scalpSignal.direction, currentPrice);
      scalpSignal.lotSize = CalculateAggressiveLotSize(scalpSignal.stopLoss, currentPrice, true);
      scalpSignal.riskReward = MathAbs(scalpSignal.takeProfit - scalpSignal.entryPrice) / MathAbs(scalpSignal.entryPrice - scalpSignal.stopLoss);
      scalpSignal.expectedProfit = scalpSignal.lotSize * MathAbs(scalpSignal.takeProfit - scalpSignal.entryPrice) * 100000;
      
      if(ActivePositions < MaxSimultaneousPositions)
      {
         ExecuteUltraSignal(scalpSignal);
      }
      
      lastScalpPrice = currentPrice;
      lastScalpTime = TimeCurrent();
   }
}

//+------------------------------------------------------------------+
//| Check Hedging Opportunity                                        |
//+------------------------------------------------------------------+
void CheckHedgingOpportunity()
{
   if(!EnableHedging) return;
   
   double totalProfit = 0.0;
   int buyPositions = 0;
   int sellPositions = 0;
   
   // Calculate total profit and position balance
   for(int i = 0; i < ActivePositions; i++)
   {
      if(position.SelectByTicket(PositionTickets[i]))
      {
         totalProfit += position.Profit();
         
         if(position.PositionType() == POSITION_TYPE_BUY)
            buyPositions++;
         else if(position.PositionType() == POSITION_TYPE_SELL)
            sellPositions++;
      }
   }
   
   // Hedge if losing and unbalanced
   if(totalProfit < -50.0 && MathAbs(buyPositions - sellPositions) >= 2)
   {
      UltraAggressiveSignal hedgeSignal;
      hedgeSignal.isHedge = true;
      hedgeSignal.confidence = 90.0;
      hedgeSignal.urgency = 85.0;
      hedgeSignal.entryPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
      hedgeSignal.signalReason = "Hedge_Protection";
      hedgeSignal.signalTime = TimeCurrent();
      
      // Hedge in opposite direction of majority
      if(buyPositions > sellPositions)
      {
         hedgeSignal.direction = SIGNAL_HEDGE_SELL;
      }
      else
      {
         hedgeSignal.direction = SIGNAL_HEDGE_BUY;
      }
      
      hedgeSignal.stopLoss = CalculateHedgeStopLoss(hedgeSignal.direction, hedgeSignal.entryPrice);
      hedgeSignal.takeProfit = CalculateHedgeTakeProfit(hedgeSignal.direction, hedgeSignal.entryPrice);
      hedgeSignal.lotSize = CalculateHedgeLotSize(totalProfit);
      hedgeSignal.riskReward = MathAbs(hedgeSignal.takeProfit - hedgeSignal.entryPrice) / MathAbs(hedgeSignal.entryPrice - hedgeSignal.stopLoss);
      hedgeSignal.expectedProfit = hedgeSignal.lotSize * MathAbs(hedgeSignal.takeProfit - hedgeSignal.entryPrice) * 100000;
      
      if(ActivePositions < MaxSimultaneousPositions && CanTrade())
      {
         ExecuteUltraSignal(hedgeSignal);
      }
   }
}

//+------------------------------------------------------------------+
//| Force Trade Entry                                                |
//+------------------------------------------------------------------+
void ForceTradeEntry()
{
   if(!AlwaysInTrade || !CanTrade()) return;
   
   // Generate a forced entry signal
   UltraAggressiveSignal forceSignal = GenerateForceSignal();
   
   if(forceSignal.direction != SIGNAL_NONE)
   {
      ExecuteUltraSignal(forceSignal);
   }
}

//+------------------------------------------------------------------+
//| Calculate Aggressive Lot Size                                    |
//+------------------------------------------------------------------+
double CalculateAggressiveLotSize(double stopLoss, double entryPrice, bool isScalp)
{
   double balance = account.Balance();
   double riskPercent = isScalp ? 3.0 : RiskPercentage;
   
   // Apply martingale if enabled
   if(EnableMartingale && ConsecutiveLosses > 0)
   {
      CurrentMultiplier = MathPow(MartingaleMultiplier, ConsecutiveLosses);
   }
   else
   {
      CurrentMultiplier = 1.0;
   }
   
   // Apply progressive risk
   if(EnableProgressiveRisk && ConsecutiveLosses >= 2)
   {
      riskPercent *= (1.0 + (ConsecutiveLosses * 0.3));
   }
   
   double riskAmount = balance * (riskPercent / 100.0) * CurrentMultiplier;
   double stopLossPoints = MathAbs(entryPrice - stopLoss);
   double tickValue = SymbolInfoDouble(Symbol, SYMBOL_TRADE_TICK_VALUE);
   double lotSize = riskAmount / (stopLossPoints * tickValue * 100000);
   
   // Normalize lot size
   double minLot = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_STEP);
   
   lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
   lotSize = MathRound(lotSize / lotStep) * lotStep;
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Calculate Scalp Stop Loss                                        |
//+------------------------------------------------------------------+
double CalculateScalpStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double stopLossPoints = 15.0; // Tight stop for scalping
   
   if(direction == SIGNAL_SCALP_BUY)
   {
      return entryPrice - (stopLossPoints * point);
   }
   else
   {
      return entryPrice + (stopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Scalp Take Profit                                      |
//+------------------------------------------------------------------+
double CalculateScalpTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   
   if(direction == SIGNAL_SCALP_BUY)
   {
      return entryPrice + (ScalpProfitPoints * point);
   }
   else
   {
      return entryPrice - (ScalpProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Instant Scalp Stop Loss                               |
//+------------------------------------------------------------------+
double CalculateInstantScalpStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double stopLossPoints = 5.0; // Very tight for instant scalping
   
   if(direction == SIGNAL_SCALP_BUY)
   {
      return entryPrice - (stopLossPoints * point);
   }
   else
   {
      return entryPrice + (stopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Instant Scalp Take Profit                             |
//+------------------------------------------------------------------+
double CalculateInstantScalpTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double takeProfitPoints = 8.0; // Quick profit for instant scalping
   
   if(direction == SIGNAL_SCALP_BUY)
   {
      return entryPrice + (takeProfitPoints * point);
   }
   else
   {
      return entryPrice - (takeProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Stop Loss                                              |
//+------------------------------------------------------------------+
double CalculateStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice - (StopLossPoints * point);
   }
   else
   {
      return entryPrice + (StopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Take Profit                                            |
//+------------------------------------------------------------------+
double CalculateTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice + (TakeProfitPoints * point);
   }
   else
   {
      return entryPrice - (TakeProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Volatility Stop Loss                                  |
//+------------------------------------------------------------------+
double CalculateVolatilityStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice, double atr)
{
   double stopLoss = atr * 2.0; // 2x ATR stop loss
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice - stopLoss;
   }
   else
   {
      return entryPrice + stopLoss;
   }
}

//+------------------------------------------------------------------+
//| Calculate Volatility Take Profit                                |
//+------------------------------------------------------------------+
double CalculateVolatilityTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice, double atr)
{
   double takeProfit = atr * 3.0; // 3x ATR take profit
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice + takeProfit;
   }
   else
   {
      return entryPrice - takeProfit;
   }
}

//+------------------------------------------------------------------+
//| Calculate Momentum Stop Loss                                    |
//+------------------------------------------------------------------+
double CalculateMomentumStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double stopLossPoints = 20.0; // Momentum stop
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice - (stopLossPoints * point);
   }
   else
   {
      return entryPrice + (stopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Momentum Take Profit                                  |
//+------------------------------------------------------------------+
double CalculateMomentumTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double takeProfitPoints = 40.0; // Momentum target
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice + (takeProfitPoints * point);
   }
   else
   {
      return entryPrice - (takeProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Hedge Stop Loss                                        |
//+------------------------------------------------------------------+
double CalculateHedgeStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double stopLossPoints = 50.0; // Wider stop for hedging
   
   if(direction == SIGNAL_HEDGE_BUY)
   {
      return entryPrice - (stopLossPoints * point);
   }
   else
   {
      return entryPrice + (stopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Hedge Take Profit                                      |
//+------------------------------------------------------------------+
double CalculateHedgeTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double takeProfitPoints = 30.0; // Conservative target for hedging
   
   if(direction == SIGNAL_HEDGE_BUY)
   {
      return entryPrice + (takeProfitPoints * point);
   }
   else
   {
      return entryPrice - (takeProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Hedge Lot Size                                         |
//+------------------------------------------------------------------+
double CalculateHedgeLotSize(double totalProfit)
{
   double balance = account.Balance();
   double hedgePercent = 5.0; // 5% for hedging
   double riskAmount = balance * (hedgePercent / 100.0);
   
   // Increase hedge size based on current loss
   if(totalProfit < -100.0)
   {
      riskAmount *= 1.5;
   }
   
   double minLot = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_STEP);
   
   double lotSize = riskAmount / 1000.0; // Simplified calculation
   lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
   lotSize = MathRound(lotSize / lotStep) * lotStep;
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Execute Flip Mode Strategy                                       |
//+------------------------------------------------------------------+
void ExecuteFlipModeStrategy()
{
   if(!FlipModeActive) return;
   
   // Check if we've reached the target
   if(AccountBalance >= WeeklyTarget)
   {
      FlipModeActive = false;
      Print("🎯 FLIP MODE COMPLETE! Target reached: $", AccountBalance);
      return;
   }
   
   // Generate flip mode signal
   UltraAggressiveSignal flipSignal = GenerateTimeframeSignal(FlipTimeframe, false);
   
   if(flipSignal.direction != SIGNAL_NONE && flipSignal.confidence >= 70.0 && CanTrade())
   {
      // Increase lot size for flip mode
      flipSignal.lotSize *= 1.5;
      flipSignal.signalReason = "Flip_Mode";
      
      ExecuteUltraSignal(flipSignal);
   }
}

//+------------------------------------------------------------------+
//| Execute Scalping Strategy                                        |
//+------------------------------------------------------------------+
void ExecuteScalpingStrategy()
{
   if(!CanTrade()) return;
   
   // Generate scalping signals
   UltraAggressiveSignal scalpSignal = GenerateTimeframeSignal(PERIOD_M1, true);
   
   if(scalpSignal.direction != SIGNAL_NONE && scalpSignal.confidence >= 65.0)
   {
      if(ActivePositions < MaxSimultaneousPositions)
      {
         ExecuteUltraSignal(scalpSignal);
      }
   }
}

//+------------------------------------------------------------------+
//| Manage All Positions                                             |
//+------------------------------------------------------------------+
void ManageAllPositions()
{
   for(int i = ActivePositions - 1; i >= 0; i--)
   {
      if(position.SelectByTicket(PositionTickets[i]))
      {
         // Update position profit
         PositionProfits[i] = position.Profit();
         
         // Check for quick exit
         if(PositionProfits[i] >= QuickExitPoints)
         {
            if(trade.PositionClose(PositionTickets[i]))
            {
               WinningTrades++;
               ConsecutiveWins++;
               ConsecutiveLosses = 0;
               RemovePositionFromTracking(i);
               continue;
            }
         }
         
         // Check for trailing stop
         if(TrailingStopPoints > 0)
         {
            ApplyTrailingStop(PositionTickets[i]);
         }
         
         // Check for time-based exit (scalping)
         if(TimeCurrent() - PositionOpenTimes[i] > 300) // 5 minutes
         {
            if(PositionProfits[i] > 0) // Only close if profitable
            {
               if(trade.PositionClose(PositionTickets[i]))
               {
                  WinningTrades++;
                  ConsecutiveWins++;
                  ConsecutiveLosses = 0;
                  RemovePositionFromTracking(i);
               }
            }
         }
      }
      else
      {
         // Position closed externally, remove from tracking
         RemovePositionFromTracking(i);
      }
   }
}

//+------------------------------------------------------------------+
//| Apply Trailing Stop                                              |
//+------------------------------------------------------------------+
void ApplyTrailingStop(ulong ticket)
{
   if(position.SelectByTicket(ticket))
   {
      double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
      double currentPrice = (position.PositionType() == POSITION_TYPE_BUY) ? 
                           SymbolInfoDouble(Symbol, SYMBOL_BID) : 
                           SymbolInfoDouble(Symbol, SYMBOL_ASK);
      
      double newStopLoss = 0.0;
      
      if(position.PositionType() == POSITION_TYPE_BUY)
      {
         newStopLoss = currentPrice - (TrailingStopPoints * point);
         if(newStopLoss > position.StopLoss())
         {
            trade.PositionModify(ticket, newStopLoss, position.TakeProfit());
         }
      }
      else if(position.PositionType() == POSITION_TYPE_SELL)
      {
         newStopLoss = currentPrice + (TrailingStopPoints * point);
         if(newStopLoss < position.StopLoss() || position.StopLoss() == 0)
         {
            trade.PositionModify(ticket, newStopLoss, position.TakeProfit());
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Remove Position From Tracking                                   |
//+------------------------------------------------------------------+
void RemovePositionFromTracking(int index)
{
   if(index >= 0 && index < ActivePositions)
   {
      // Shift remaining positions
      for(int i = index; i < ActivePositions - 1; i++)
      {
         PositionTickets[i] = PositionTickets[i + 1];
         PositionOpenTimes[i] = PositionOpenTimes[i + 1];
         PositionProfits[i] = PositionProfits[i + 1];
      }
      
      ActivePositions--;
   }
}

//+------------------------------------------------------------------+
//| Update Position Tracking                                         |
//+------------------------------------------------------------------+
void UpdatePositionTracking()
{
   // Clean up closed positions
   for(int i = ActivePositions - 1; i >= 0; i--)
   {
      if(!position.SelectByTicket(PositionTickets[i]))
      {
         RemovePositionFromTracking(i);
      }
   }
}

//+------------------------------------------------------------------+
//| Update Account Info                                              |
//+------------------------------------------------------------------+
void UpdateAccountInfo()
{
   AccountBalance = account.Balance();
   double equity = account.Equity();
   
   CurrentDrawdown = ((InitialBalance - equity) / InitialBalance) * 100.0;
   MaxDrawdown = MathMax(MaxDrawdown, CurrentDrawdown);
   
   if(TotalTrades > 0)
   {
      WinRate = (double)WinningTrades / TotalTrades * 100.0;
   }
}

//+------------------------------------------------------------------+
//| Update Market State                                              |
//+------------------------------------------------------------------+
void UpdateMarketState()
{
   // Get current market data
   double currentPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   double ma20[], ma50[], atr[];
   
   ArraySetAsSeries(ma20, true);
   ArraySetAsSeries(ma50, true);
   ArraySetAsSeries(atr, true);
   
   if(CopyBuffer(MA_Handle_20, 0, 0, 3, ma20) > 0 && 
      CopyBuffer(MA_Handle_50, 0, 0, 3, ma50) > 0 && 
      CopyBuffer(ATR_Handle, 0, 0, 3, atr) > 0)
   {
      marketState.inUptrend = (currentPrice > ma20[0] && ma20[0] > ma50[0]);
      marketState.inDowntrend = (currentPrice < ma20[0] && ma20[0] < ma50[0]);
      marketState.inRange = (!marketState.inUptrend && !marketState.inDowntrend);
      marketState.volatility = atr[0];
      marketState.momentum = (currentPrice - ma20[0]) / ma20[0] * 100;
      marketState.strength = MathAbs(marketState.momentum);
      marketState.opportunity = marketState.strength * (marketState.volatility * 1000);
   }
}

//+------------------------------------------------------------------+
//| Setup Flip Mode Targets                                         |
//+------------------------------------------------------------------+
void SetupFlipModeTargets()
{
   DailyTarget = InitialBalance * 0.58; // 58% daily growth
   WeeklyTarget = 100000.0; // Target $100k from $1k
   FlipModeActive = true;
   
   Print("🚀 Flip Mode Activated - Target: $", WeeklyTarget);
}

//+------------------------------------------------------------------+
//| Initialize Stats                                                 |
//+------------------------------------------------------------------+
void InitializeStats()
{
   stats.totalTrades = 0;
   stats.winningTrades = 0;
   stats.losingTrades = 0;
   stats.totalProfit = 0.0;
   stats.totalLoss = 0.0;
   stats.largestWin = 0.0;
   stats.largestLoss = 0.0;
   stats.averageWin = 0.0;
   stats.averageLoss = 0.0;
   stats.profitFactor = 0.0;
   stats.winRate = 0.0;
   stats.maxConsecutiveWins = 0;
   stats.maxConsecutiveLosses = 0;
   stats.maxDrawdown = 0.0;
   stats.recovery = 0.0;
}

//+------------------------------------------------------------------+
//| Update Stats                                                     |
//+------------------------------------------------------------------+
void UpdateStats()
{
   stats.totalTrades = TotalTrades;
   stats.winningTrades = WinningTrades;
   stats.losingTrades = TotalTrades - WinningTrades;
   stats.winRate = WinRate;
   stats.maxConsecutiveWins = MathMax(stats.maxConsecutiveWins, ConsecutiveWins);
   stats.maxConsecutiveLosses = MathMax(stats.maxConsecutiveLosses, ConsecutiveLosses);
   stats.maxDrawdown = MaxDrawdown;
   stats.recovery = (AccountBalance - InitialBalance) / InitialBalance * 100.0;
}

//+------------------------------------------------------------------+
//| Log Ultra Aggressive Trade                                       |
//+------------------------------------------------------------------+
void LogUltraAggressiveTrade(UltraAggressiveSignal &signal, ulong ticket)
{
   string logMessage = StringFormat("🔥 ULTRA AGGRESSIVE TRADE #%d:\n" +
                                   "Time: %s | Ticket: %d\n" +
                                   "Signal: %s | Reason: %s\n" +
                                   "Entry: %.5f | SL: %.5f | TP: %.5f\n" +
                                   "Lot Size: %.2f | Confidence: %.0f%%\n" +
                                   "R:R: %.2f | Expected: $%.2f\n" +
                                   "Consecutive Wins: %d | Losses: %d\n" +
                                   "Active: %d/%d | Trades/Hour: %d/%d",
                                   TotalTrades,
                                   TimeToString(TimeCurrent()),
                                   ticket,
                                   EnumToString(signal.direction),
                                   signal.signalReason,
                                   signal.entryPrice,
                                   signal.stopLoss,
                                   signal.takeProfit,
                                   signal.lotSize,
                                   signal.confidence,
                                   signal.riskReward,
                                   signal.expectedProfit,
                                   ConsecutiveWins,
                                   ConsecutiveLosses,
                                   ActivePositions,
                                   MaxSimultaneousPositions,
                                   TradesThisHour,
                                   MaxTradesPerHour);
   
   Print(logMessage);
}

//+------------------------------------------------------------------+
//| Create Ultra Notification                                        |
//+------------------------------------------------------------------+
string CreateUltraNotification(UltraAggressiveSignal &signal)
{
   string bonusText = "";
   if(ConsecutiveWins >= WinStreakForBonus)
   {
      bonusText = " 🎰 20X BONUS!";
   }
   else if(ConsecutiveWins >= 2)
   {
      bonusText = " 🚀 PROGRESSIVE!";
   }
   
   return StringFormat("🔥 ULTRA AGGRESSIVE SIGNAL%s\n" +
                      "Signal: %s | Confidence: %.0f%%\n" +
                      "Entry: %.5f | R:R: %.2f\n" +
                      "Expected: $%.2f | Frequency: %ds\n" +
                      "Wins: %d | Losses: %d\n" +
                      "Active: %d/%d positions",
                      bonusText,
                      EnumToString(signal.direction),
                      signal.confidence,
                      signal.entryPrice,
                      signal.riskReward,
                      signal.expectedProfit,
                      TradeFrequencySeconds,
                      ConsecutiveWins,
                      ConsecutiveLosses,
                      ActivePositions,
                      MaxSimultaneousPositions);
}

//+------------------------------------------------------------------+
//| Save Ultra Aggressive Stats                                      |
//+------------------------------------------------------------------+
void SaveUltraAggressiveStats()
{
   Print("🔥 ULTRA AGGRESSIVE TRADING SESSION COMPLETE");
   Print("💰 Total Trades: ", TotalTrades);
   Print("🎯 Win Rate: ", WinRate, "%");
   Print("💵 Final Balance: $", AccountBalance);
   Print("📊 Max Drawdown: ", MaxDrawdown, "%");
   Print("🏆 Max Consecutive Wins: ", stats.maxConsecutiveWins);
   Print("💥 Max Consecutive Losses: ", stats.maxConsecutiveLosses);
   Print("⚡ Trades This Hour: ", TradesThisHour);
   Print("📅 Trades This Day: ", TradesThisDay);
   Print("🔄 Trade Frequency: ", TradeFrequencySeconds, " seconds");
   Print("🚀 Flip Mode Status: ", FlipModeActive ? "ACTIVE" : "COMPLETE");
   Print("📈 Account Recovery: ", stats.recovery, "%");
}

//+------------------------------------------------------------------+
