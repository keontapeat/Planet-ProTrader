//+------------------------------------------------------------------+
//|                                                     GOLDEX_AI.mq5|
//|                                  Copyright 2024, Keonta J. Peat |
//|                                     Enhanced AI Trading System   |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, Keonta Peat"
#property link      "https://www.mql5.com"
#property version   "2.0"
#property strict

//--- Include necessary libraries
#include <Trade\Trade.mqh>
#include <Math\Stat\Math.mqh>
#include <Arrays\ArrayObj.mqh>

//--- Global variables
CTrade trade;
CPositionInfo position;
COrderInfo order;
CSymbolInfo symbol;
CAccountInfo account;

//--- Input parameters
input group "=== TRADING PARAMETERS ==="
input double LotSize = 0.01;                    // Lot size
input int StopLoss = 50;                        // Stop loss in points
input int TakeProfit = 100;                     // Take profit in points
input int MaxPositions = 3;                     // Maximum positions
input bool UseTrailingStop = true;              // Use trailing stop
input int TrailingStop = 30;                    // Trailing stop distance
input int TrailingStep = 10;                    // Trailing step

input group "=== AI PARAMETERS ==="
input int AILookback = 20;                      // AI analysis lookback
input double AIConfidence = 0.75;               // AI confidence threshold
input bool UseMLFilter = true;                  // Use machine learning filter
input int NeuralLayers = 3;                     // Neural network layers
input double LearningRate = 0.01;               // Learning rate

input group "=== RISK MANAGEMENT ==="
input double MaxRiskPercent = 2.0;              // Maximum risk per trade (%)
input double MaxDailyLoss = 5.0;                // Maximum daily loss (%)
input double MaxDrawdown = 10.0;                // Maximum drawdown (%)
input bool UsePositionSizing = true;            // Use dynamic position sizing
input bool UseCorrelationFilter = true;         // Use correlation filter

input group "=== MARKET ANALYSIS ==="
input bool UseMultiTimeframe = true;            // Use multiple timeframes
input ENUM_TIMEFRAMES TimeFrame1 = PERIOD_M15;  // Primary timeframe
input ENUM_TIMEFRAMES TimeFrame2 = PERIOD_H1;   // Secondary timeframe
input ENUM_TIMEFRAMES TimeFrame3 = PERIOD_H4;   // Tertiary timeframe
input bool UseVolumeAnalysis = true;            // Use volume analysis
input bool UseNewsFilter = true;                // Use news filter

input group "=== NOTIFICATION SETTINGS ==="
input bool SendPushNotifications = true;        // Send push notifications
input bool SendEmailAlerts = false;             // Send email alerts
input bool PlaySoundAlerts = true;              // Play sound alerts
input string SoundFile = "alert.wav";           // Sound file

//--- Global arrays for AI analysis
double priceData[];
double volumeData[];
double indicatorData[];
double predictions[];
double confidence[];

//--- Trading statistics
struct TradingStats {
    int winningTrades;
    int losingTrades;
    int consecutiveWins;
    int consecutiveLosses;
    double avgWinSize;
    double avgLossSize;
    double totalProfit;
    double totalLoss;
    double winRate;
    double profitFactor;
    double sharpeRatio;
    double maxDrawdown;
    double currentDrawdown;
    datetime lastTradeTime;
};

TradingStats stats;

//--- Market conditions
struct MarketConditions {
    bool isTrending;
    bool isVolatile;
    bool isRanging;
    double trendStrength;
    double volatility;
    double momentum;
    double support;
    double resistance;
    ENUM_SIGNAL_DIRECTION trend;
};

MarketConditions market;

//--- AI Neural Network structure
struct NeuralNetwork {
    double weights[100][100];
    double biases[100];
    double neurons[100];
    int inputSize;
    int hiddenSize;
    int outputSize;
    double learningRate;
};

NeuralNetwork network;

//--- Risk management
struct RiskManager {
    double accountBalance;
    double accountEquity;
    double usedMargin;
    double freeMargin;
    double marginLevel;
    double dailyPnL;
    double maxDailyLoss;
    double currentDrawdown;
    bool riskLimitExceeded;
};

RiskManager riskMgr;

//--- Signal types
enum ENUM_SIGNAL_DIRECTION {
    SIGNAL_BUY,
    SIGNAL_SELL,
    SIGNAL_HOLD
};

enum ENUM_SIGNAL_STRENGTH {
    SIGNAL_WEAK,
    SIGNAL_MEDIUM,
    SIGNAL_STRONG
};

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit() {
    Print("üöÄ GOLDEX AI Expert Advisor Starting...");
    
    // Initialize trading objects
    if (!InitializeTrading()) {
        Print("‚ùå Failed to initialize trading objects");
        return INIT_FAILED;
    }
    
    // Initialize AI components
    if (!InitializeAI()) {
        Print("‚ùå Failed to initialize AI components");
        return INIT_FAILED;
    }
    
    // Initialize risk management
    InitializeRiskManagement();
    
    // Initialize statistics
    InitializeStatistics();
    
    // Validate inputs
    if (!ValidateInputs()) {
        Print("‚ùå Invalid input parameters");
        return INIT_FAILED;
    }
    
    // Set up chart indicators
    SetupChartIndicators();
    
    Print("‚úÖ GOLDEX AI Expert Advisor initialized successfully!");
    Print("üìä Account Balance: $", DoubleToString(account.Balance(), 2));
    Print("üíº Account Equity: $", DoubleToString(account.Equity(), 2));
    Print("üéØ Max Risk Per Trade: ", DoubleToString(MaxRiskPercent, 1), "%");
    
    return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    Print("üõë GOLDEX AI Expert Advisor shutting down...");
    
    // Close all positions if needed
    if (reason == REASON_REMOVE || reason == REASON_RECOMPILE) {
        CloseAllPositions();
    }
    
    // Save statistics
    SaveStatistics();
    
    // Clean up resources
    CleanupResources();
    
    Print("üëã GOLDEX AI Expert Advisor shutdown complete");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick() {
    // Update market data
    UpdateMarketData();
    
    // Update risk management
    UpdateRiskManagement();
    
    // Check risk limits
    if (riskMgr.riskLimitExceeded) {
        Print("‚ö†Ô∏è Risk limit exceeded. Stopping trading.");
        return;
    }
    
    // Update AI analysis
    UpdateAIAnalysis();
    
    // Analyze market conditions
    AnalyzeMarketConditions();
    
    // Generate trading signals
    ENUM_SIGNAL_DIRECTION signal = GenerateSignal();
    
    // Execute trades based on signals
    ExecuteTradingLogic(signal);
    
    // Manage existing positions
    ManagePositions();
    
    // Update statistics
    UpdateStatistics();
    
    // Display dashboard
    DisplayDashboard();
}

//+------------------------------------------------------------------+
//| Trade transaction function                                       |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans, 
                       const MqlTradeRequest& request, 
                       const MqlTradeResult& result) {
    
    if (trans.type == TRADE_TRANSACTION_DEAL_ADD) {
        ProcessTradeResult(trans, result);
    }
}

//+------------------------------------------------------------------+
//| Initialize trading objects                                       |
//+------------------------------------------------------------------+
bool InitializeTrading() {
    if (!trade.SetExpertMagicNumber(123456)) {
        Print("‚ùå Failed to set magic number");
        return false;
    }
    
    if (!symbol.Name(_Symbol)) {
        Print("‚ùå Failed to initialize symbol");
        return false;
    }
    
    trade.SetDeviationInPoints(10);
    trade.SetTypeFilling(ORDER_FILLING_FOK);
    
    return true;
}

//+------------------------------------------------------------------+
//| Initialize AI components                                         |
//+------------------------------------------------------------------+
bool InitializeAI() {
    // Initialize neural network
    network.inputSize = 10;
    network.hiddenSize = 20;
    network.outputSize = 3;
    network.learningRate = LearningRate;
    
    // Initialize random weights
    for (int i = 0; i < network.hiddenSize; i++) {
        for (int j = 0; j < network.inputSize; j++) {
            network.weights[i][j] = (MathRand() / 32768.0) - 0.5;
        }
        network.biases[i] = (MathRand() / 32768.0) - 0.5;
    }
    
    // Resize arrays
    ArrayResize(priceData, AILookback);
    ArrayResize(volumeData, AILookback);
    ArrayResize(indicatorData, AILookback);
    ArrayResize(predictions, 3);
    ArrayResize(confidence, 3);
    
    return true;
}

//+------------------------------------------------------------------+
//| Initialize risk management                                       |
//+------------------------------------------------------------------+
void InitializeRiskManagement() {
    riskMgr.accountBalance = account.Balance();
    riskMgr.accountEquity = account.Equity();
    riskMgr.maxDailyLoss = riskMgr.accountBalance * MaxDailyLoss / 100.0;
    riskMgr.dailyPnL = 0.0;
    riskMgr.currentDrawdown = 0.0;
    riskMgr.riskLimitExceeded = false;
}

//+------------------------------------------------------------------+
//| Initialize statistics                                            |
//+------------------------------------------------------------------+
void InitializeStatistics() {
    stats.winningTrades = 0;
    stats.losingTrades = 0;
    stats.consecutiveWins = 0;
    stats.consecutiveLosses = 0;
    stats.avgWinSize = 0.0;
    stats.avgLossSize = 0.0;
    stats.totalProfit = 0.0;
    stats.totalLoss = 0.0;
    stats.winRate = 0.0;
    stats.profitFactor = 0.0;
    stats.sharpeRatio = 0.0;
    stats.maxDrawdown = 0.0;
    stats.currentDrawdown = 0.0;
    stats.lastTradeTime = 0;
}

//+------------------------------------------------------------------+
//| Validate input parameters                                        |
//+------------------------------------------------------------------+
bool ValidateInputs() {
    if (LotSize <= 0) {
        Print("‚ùå Invalid lot size: ", LotSize);
        return false;
    }
    
    if (StopLoss < 0 || TakeProfit < 0) {
        Print("‚ùå Invalid stop loss or take profit values");
        return false;
    }
    
    if (MaxRiskPercent <= 0 || MaxRiskPercent > 100) {
        Print("‚ùå Invalid risk percentage: ", MaxRiskPercent);
        return false;
    }
    
    if (AIConfidence < 0 || AIConfidence > 1) {
        Print("‚ùå Invalid AI confidence: ", AIConfidence);
        return false;
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| Set up chart indicators                                          |
//+------------------------------------------------------------------+
void SetupChartIndicators() {
    // Create custom indicators for display
    ChartIndicatorAdd(0, 0, iMA(_Symbol, PERIOD_CURRENT, 20, 0, MODE_SMA, PRICE_CLOSE));
    ChartIndicatorAdd(0, 0, iMA(_Symbol, PERIOD_CURRENT, 50, 0, MODE_SMA, PRICE_CLOSE));
    ChartIndicatorAdd(0, 1, iRSI(_Symbol, PERIOD_CURRENT, 14, PRICE_CLOSE));
    ChartIndicatorAdd(0, 2, iMACD(_Symbol, PERIOD_CURRENT, 12, 26, 9, PRICE_CLOSE));
}

//+------------------------------------------------------------------+
//| Update market data                                               |
//+------------------------------------------------------------------+
void UpdateMarketData() {
    // Update price data
    for (int i = AILookback - 1; i > 0; i--) {
        priceData[i] = priceData[i-1];
    }
    priceData[0] = symbol.Bid();
    
    // Update volume data
    for (int i = AILookback - 1; i > 0; i--) {
        volumeData[i] = volumeData[i-1];
    }
    volumeData[0] = (double)iVolume(_Symbol, PERIOD_CURRENT, 0);
    
    // Update symbol info
    symbol.RefreshRates();
}

//+------------------------------------------------------------------+
//| Update risk management                                           |
//+------------------------------------------------------------------+
void UpdateRiskManagement() {
    riskMgr.accountBalance = account.Balance();
    riskMgr.accountEquity = account.Equity();
    riskMgr.usedMargin = account.MarginUsed();
    riskMgr.freeMargin = account.FreeMargin();
    riskMgr.marginLevel = account.MarginLevel();
    
    // Calculate daily P&L
    riskMgr.dailyPnL = riskMgr.accountEquity - riskMgr.accountBalance;
    
    // Check risk limits
    if (riskMgr.dailyPnL < -riskMgr.maxDailyLoss) {
        riskMgr.riskLimitExceeded = true;
        SendNotification("‚ö†Ô∏è Daily loss limit exceeded!");
    }
    
    // Calculate drawdown
    double peak = MathMax(riskMgr.accountBalance, riskMgr.accountEquity);
    riskMgr.currentDrawdown = (peak - riskMgr.accountEquity) / peak * 100.0;
    
    if (riskMgr.currentDrawdown > MaxDrawdown) {
        riskMgr.riskLimitExceeded = true;
        SendNotification("‚ö†Ô∏è Maximum drawdown exceeded!");
    }
}

//+------------------------------------------------------------------+
//| Update AI analysis                                               |
//+------------------------------------------------------------------+
void UpdateAIAnalysis() {
    // Prepare input data for neural network
    double inputs[10];
    
    // Price-based inputs
    inputs[0] = NormalizePrice(priceData[0]);
    inputs[1] = NormalizePrice(priceData[1] - priceData[0]); // Price change
    inputs[2] = NormalizePrice(CalculateMovingAverage(priceData, 5));
    inputs[3] = NormalizePrice(CalculateMovingAverage(priceData, 10));
    
    // Technical indicators
    inputs[4] = NormalizeIndicator(CalculateRSI(priceData, 14));
    inputs[5] = NormalizeIndicator(CalculateMACD(priceData));
    inputs[6] = NormalizeIndicator(CalculateBollingerBands(priceData));
    
    // Volume analysis
    inputs[7] = NormalizeVolume(volumeData[0]);
    inputs[8] = NormalizeVolume(CalculateVolumeMA(volumeData, 10));
    
    // Market volatility
    inputs[9] = NormalizeVolatility(CalculateVolatility(priceData, 20));
    
    // Run neural network
    RunNeuralNetwork(inputs);
    
    // Update predictions and confidence
    for (int i = 0; i < 3; i++) {
        predictions[i] = network.neurons[network.hiddenSize + i];
        confidence[i] = MathAbs(predictions[i]);
    }
}

//+------------------------------------------------------------------+
//| Analyze market conditions                                        |
//+------------------------------------------------------------------+
void AnalyzeMarketConditions() {
    // Calculate trend strength
    double sma20 = CalculateMovingAverage(priceData, 20);
    double sma50 = CalculateMovingAverage(priceData, 50);
    
    market.trendStrength = MathAbs(sma20 - sma50) / symbol.Point();
    market.isTrending = market.trendStrength > 100;
    
    // Calculate volatility
    market.volatility = CalculateVolatility(priceData, 20);
    market.isVolatile = market.volatility > 0.02;
    
    // Determine market state
    if (market.isTrending && !market.isVolatile) {
        market.isRanging = false;
    } else if (!market.isTrending && market.isVolatile) {
        market.isRanging = true;
    }
    
    // Calculate momentum
    market.momentum = (priceData[0] - priceData[10]) / priceData[10];
    
    // Calculate support and resistance
    market.support = CalculateSupport(priceData, AILookback);
    market.resistance = CalculateResistance(priceData, AILookback);
    
    // Determine overall trend
    if (sma20 > sma50 && market.momentum > 0) {
        market.trend = SIGNAL_BUY;
    } else if (sma20 < sma50 && market.momentum < 0) {
        market.trend = SIGNAL_SELL;
    } else {
        market.trend = SIGNAL_HOLD;
    }
}

//+------------------------------------------------------------------+
//| Generate trading signal                                          |
//+------------------------------------------------------------------+
ENUM_SIGNAL_DIRECTION GenerateSignal() {
    // Get AI prediction
    int maxIndex = 0;
    double maxConfidence = 0;
    
    for (int i = 0; i < 3; i++) {
        if (confidence[i] > maxConfidence) {
            maxConfidence = confidence[i];
            maxIndex = i;
        }
    }
    
    // Check if confidence is above threshold
    if (maxConfidence < AIConfidence) {
        return SIGNAL_HOLD;
    }
    
    ENUM_SIGNAL_DIRECTION aiSignal = (ENUM_SIGNAL_DIRECTION)maxIndex;
    
    // Apply filters
    if (UseMLFilter && !PassMLFilter(aiSignal)) {
        return SIGNAL_HOLD;
    }
    
    if (UseCorrelationFilter && !PassCorrelationFilter(aiSignal)) {
        return SIGNAL_HOLD;
    }
    
    if (UseNewsFilter && !PassNewsFilter()) {
        return SIGNAL_HOLD;
    }
    
    // Multi-timeframe analysis
    if (UseMultiTimeframe && !PassMultiTimeframeFilter(aiSignal)) {
        return SIGNAL_HOLD;
    }
    
    // Volume confirmation
    if (UseVolumeAnalysis && !PassVolumeFilter(aiSignal)) {
        return SIGNAL_HOLD;
    }
    
    return aiSignal;
}

//+------------------------------------------------------------------+
//| Execute trading logic                                            |
//+------------------------------------------------------------------+
void ExecuteTradingLogic(ENUM_SIGNAL_DIRECTION signal) {
    if (signal == SIGNAL_HOLD) {
        return;
    }
    
    // Check if we can open new positions
    if (CountOpenPositions() >= MaxPositions) {
        return;
    }
    
    // Calculate position size
    double lotSize = CalculatePositionSize();
    
    // Check minimum lot size
    if (lotSize < symbol.LotsMin()) {
        Print("‚ö†Ô∏è Calculated lot size too small: ", lotSize);
        return;
    }
    
    // Place order
    if (signal == SIGNAL_BUY) {
        OpenBuyPosition(lotSize);
    } else if (signal == SIGNAL_SELL) {
        OpenSellPosition(lotSize);
    }
}

//+------------------------------------------------------------------+
//| Open buy position                                                |
//+------------------------------------------------------------------+
void OpenBuyPosition(double lotSize) {
    double price = symbol.Ask();
    double sl = (StopLoss > 0) ? price - StopLoss * symbol.Point() : 0;
    double tp = (TakeProfit > 0) ? price + TakeProfit * symbol.Point() : 0;
    
    if (trade.Buy(lotSize, _Symbol, price, sl, tp, "GOLDEX AI BUY")) {
        Print("‚úÖ BUY order placed successfully");
        Print("üí∞ Lot Size: ", lotSize);
        Print("üí≤ Price: ", price);
        Print("üõë Stop Loss: ", sl);
        Print("üéØ Take Profit: ", tp);
        
        SendNotification("üìà BUY signal executed!");
        
        if (PlaySoundAlerts) {
            PlaySound(SoundFile);
        }
    } else {
        Print("‚ùå Failed to place BUY order. Error: ", trade.ResultRetcode());
        Print("üìù Description: ", trade.ResultRetcodeDescription());
    }
}

//+------------------------------------------------------------------+
//| Open sell position                                               |
//+------------------------------------------------------------------+
void OpenSellPosition(double lotSize) {
    double price = symbol.Bid();
    double sl = (StopLoss > 0) ? price + StopLoss * symbol.Point() : 0;
    double tp = (TakeProfit > 0) ? price - TakeProfit * symbol.Point() : 0;
    
    if (trade.Sell(lotSize, _Symbol, price, sl, tp, "GOLDEX AI SELL")) {
        Print("‚úÖ SELL order placed successfully");
        Print("üí∞ Lot Size: ", lotSize);
        Print("üí≤ Price: ", price);
        Print("üõë Stop Loss: ", sl);
        Print("üéØ Take Profit: ", tp);
        
        SendNotification("üìâ SELL signal executed!");
        
        if (PlaySoundAlerts) {
            PlaySound(SoundFile);
        }
    } else {
        Print("‚ùå Failed to place SELL order. Error: ", trade.ResultRetcode());
        Print("üìù Description: ", trade.ResultRetcodeDescription());
    }
}

//+------------------------------------------------------------------+
//| Manage existing positions                                        |
//+------------------------------------------------------------------+
void ManagePositions() {
    for (int i = PositionsTotal() - 1; i >= 0; i--) {
        if (position.SelectByIndex(i)) {
            if (position.Symbol() == _Symbol && position.Magic() == 123456) {
                // Apply trailing stop
                if (UseTrailingStop) {
                    ApplyTrailingStop(position.Ticket());
                }
                
                // Check for position management rules
                CheckPositionManagement(position.Ticket());
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Apply trailing stop                                              |
//+------------------------------------------------------------------+
void ApplyTrailingStop(ulong ticket) {
    if (!position.SelectByTicket(ticket)) {
        return;
    }
    
    double currentPrice = (position.PositionType() == POSITION_TYPE_BUY) ? symbol.Bid() : symbol.Ask();
    double currentSL = position.StopLoss();
    double newSL = 0;
    
    if (position.PositionType() == POSITION_TYPE_BUY) {
        newSL = currentPrice - TrailingStop * symbol.Point();
        if (newSL > currentSL + TrailingStep * symbol.Point()) {
            trade.PositionModify(ticket, newSL, position.TakeProfit());
        }
    } else {
        newSL = currentPrice + TrailingStop * symbol.Point();
        if (newSL < currentSL - TrailingStep * symbol.Point()) {
            trade.PositionModify(ticket, newSL, position.TakeProfit());
        }
    }
}

//+------------------------------------------------------------------+
//| Check position management                                        |
//+------------------------------------------------------------------+
void CheckPositionManagement(ulong ticket) {
    if (!position.SelectByTicket(ticket)) {
        return;
    }
    
    double profit = position.Profit();
    double volume = position.Volume();
    
    // Partial close on significant profit
    if (profit > 100 && volume > symbol.LotsMin()) {
        double closeVolume = volume * 0.5;
        trade.PositionClosePartial(ticket, closeVolume);
        Print("üí∞ Partial close executed for ticket: ", ticket);
    }
    
    // Emergency close on high loss
    if (profit < -500) {
        trade.PositionClose(ticket);
        Print("üö® Emergency close executed for ticket: ", ticket);
    }
}

//+------------------------------------------------------------------+
//| Count open positions                                             |
//+------------------------------------------------------------------+
int CountOpenPositions() {
    int count = 0;
    for (int i = 0; i < PositionsTotal(); i++) {
        if (position.SelectByIndex(i)) {
            if (position.Symbol() == _Symbol && position.Magic() == 123456) {
                count++;
            }
        }
    }
    return count;
}

//+------------------------------------------------------------------+
//| Calculate position size                                          |
//+------------------------------------------------------------------+
double CalculatePositionSize() {
    if (!UsePositionSizing) {
        return LotSize;
    }
    
    double accountBalance = account.Balance();
    double riskAmount = accountBalance * MaxRiskPercent / 100.0;
    double stopLossPoints = StopLoss * symbol.Point();
    double tickValue = symbol.TickValue();
    
    if (stopLossPoints == 0 || tickValue == 0) {
        return LotSize;
    }
    
    double positionSize = riskAmount / (stopLossPoints * tickValue);
    
    // Ensure position size is within limits
    positionSize = MathMax(positionSize, symbol.LotsMin());
    positionSize = MathMin(positionSize, symbol.LotsMax());
    
    return NormalizeDouble(positionSize, 2);
}

//+------------------------------------------------------------------+
//| Close all positions                                              |
//+------------------------------------------------------------------+
void CloseAllPositions() {
    for (int i = PositionsTotal() - 1; i >= 0; i--) {
        if (position.SelectByIndex(i)) {
            if (position.Symbol() == _Symbol && position.Magic() == 123456) {
                trade.PositionClose(position.Ticket());
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Process trade result                                             |
//+------------------------------------------------------------------+
void ProcessTradeResult(const MqlTradeTransaction& trans, const MqlTradeResult& result) {
    if (result.retcode == TRADE_RETCODE_DONE) {
        // Update statistics
        if (trans.type == TRADE_TRANSACTION_DEAL_ADD) {
            UpdateTradeStatistics(trans.deal, result.deal);
        }
        
        // Send notification
        string message = StringFormat("‚úÖ Trade executed: %s %.2f lots at %.5f", 
                                    trans.type == TRADE_TRANSACTION_DEAL_ADD ? "BUY" : "SELL",
                                    trans.volume, trans.price);
        SendNotification(message);
    }
}

//+------------------------------------------------------------------+
//| Update trade statistics                                          |
//+------------------------------------------------------------------+
void UpdateTradeStatistics(ulong dealTicket, ulong deal) {
    CDealInfo dealInfo;
    if (dealInfo.SelectByIndex(dealTicket)) {
        double profit = dealInfo.Profit();
        
        if (profit > 0) {
            stats.winningTrades++;
            stats.totalProfit += profit;
            stats.consecutiveWins++;
            stats.consecutiveLosses = 0;
        } else {
            stats.losingTrades++;
            stats.totalLoss += MathAbs(profit);
            stats.consecutiveLosses++;
            stats.consecutiveWins = 0;
        }
        
        // Calculate statistics
        int totalTrades = stats.winningTrades + stats.losingTrades;
        if (totalTrades > 0) {
            stats.winRate = (double)stats.winningTrades / totalTrades * 100.0;
        }
        
        if (stats.losingTrades > 0) {
            stats.avgWinSize = stats.totalProfit / stats.winningTrades;
            stats.avgLossSize = stats.totalLoss / stats.losingTrades;
            stats.profitFactor = stats.totalProfit / stats.totalLoss;
        }
    }
}

//+------------------------------------------------------------------+
//| Update statistics                                                |
//+------------------------------------------------------------------+
void UpdateStatistics() {
    // Update current drawdown
    double currentEquity = account.Equity();
    double maxEquity = MathMax(account.Balance(), currentEquity);
    stats.currentDrawdown = (maxEquity - currentEquity) / maxEquity * 100.0;
    
    if (stats.currentDrawdown > stats.maxDrawdown) {
        stats.maxDrawdown = stats.currentDrawdown;
    }
}

//+------------------------------------------------------------------+
//| Display dashboard                                                |
//+------------------------------------------------------------------+
void DisplayDashboard() {
    static datetime lastUpdate = 0;
    
    // Update dashboard every 5 seconds
    if (TimeCurrent() - lastUpdate < 5) {
        return;
    }
    
    lastUpdate = TimeCurrent();
    
    // Create dashboard comment
    string dashboard = "";
    dashboard += "ü§ñ GOLDEX AI TRADING SYSTEM\n";
    dashboard += "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n";
    dashboard += StringFormat("üí∞ Account Balance: $%.2f\n", account.Balance());
    dashboard += StringFormat("üíº Account Equity: $%.2f\n", account.Equity());
    dashboard += StringFormat("üìä Free Margin: $%.2f\n", account.FreeMargin());
    dashboard += StringFormat("üìà Margin Level: %.1f%%\n", account.MarginLevel());
    dashboard += "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n";
    dashboard += StringFormat("üéØ Win Rate: %.1f%%\n", stats.winRate);
    dashboard += StringFormat("üèÜ Winning Trades: %d\n", stats.winningTrades);
    dashboard += StringFormat("üìâ Losing Trades: %d\n", stats.losingTrades);
    dashboard += StringFormat("üíé Profit Factor: %.2f\n", stats.profitFactor);
    dashboard += StringFormat("‚ö° Current Drawdown: %.1f%%\n", stats.currentDrawdown);
    dashboard += "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n";
    dashboard += StringFormat("üìä Open Positions: %d\n", CountOpenPositions());
    dashboard += StringFormat("üé≤ AI Confidence: %.1f%%\n", GetMaxConfidence() * 100);
    dashboard += StringFormat("üìà Trend: %s\n", GetTrendString());
    dashboard += StringFormat("üåä Volatility: %.4f\n", market.volatility);
    dashboard += "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n";
    dashboard += StringFormat("‚è∞ Last Update: %s\n", TimeToString(TimeCurrent()));
    
    Comment(dashboard);
}

//+------------------------------------------------------------------+
//| Get maximum confidence                                           |
//+------------------------------------------------------------------+
double GetMaxConfidence() {
    double maxConf = 0;
    for (int i = 0; i < 3; i++) {
        if (confidence[i] > maxConf) {
            maxConf = confidence[i];
        }
    }
    return maxConf;
}

//+------------------------------------------------------------------+
//| Get trend string                                                 |
//+------------------------------------------------------------------+
string GetTrendString() {
    switch (market.trend) {
        case SIGNAL_BUY: return "üìà BULLISH";
        case SIGNAL_SELL: return "üìâ BEARISH";
        default: return "‚û°Ô∏è NEUTRAL";
    }
}

//+------------------------------------------------------------------+
//| Send notification                                                |
//+------------------------------------------------------------------+
void SendNotification(string message) {
    if (SendPushNotifications) {
        SendNotification(message);
    }
    
    if (SendEmailAlerts) {
        SendMail("GOLDEX AI Alert", message);
    }
    
    Print(message);
}

//+------------------------------------------------------------------+
//| Save statistics                                                  |
//+------------------------------------------------------------------+
void SaveStatistics() {
    string filename = "GOLDEX_AI_Stats.csv";
    int handle = FileOpen(filename, FILE_WRITE | FILE_CSV);
    
    if (handle != INVALID_HANDLE) {
        FileWrite(handle, "Metric", "Value");
        FileWrite(handle, "Win Rate", stats.winRate);
        FileWrite(handle, "Winning Trades", stats.winningTrades);
        FileWrite(handle, "Losing Trades", stats.losingTrades);
        FileWrite(handle, "Profit Factor", stats.profitFactor);
        FileWrite(handle, "Max Drawdown", stats.maxDrawdown);
        FileWrite(handle, "Total Profit", stats.totalProfit);
        FileWrite(handle, "Total Loss", stats.totalLoss);
        
        FileClose(handle);
        Print("üìä Statistics saved to ", filename);
    }
}

//+------------------------------------------------------------------+
//| Clean up resources                                               |
//+------------------------------------------------------------------+
void CleanupResources() {
    ArrayFree(priceData);
    ArrayFree(volumeData);
    ArrayFree(indicatorData);
    ArrayFree(predictions);
    ArrayFree(confidence);
    
    Comment("");
}

//+------------------------------------------------------------------+
//| Helper Functions                                                 |
//+------------------------------------------------------------------+

double NormalizePrice(double price) {
    return (price - priceData[0]) / priceData[0];
}

double NormalizeIndicator(double value) {
    return (value - 50.0) / 50.0;
}

double NormalizeVolume(double volume) {
    return MathLog(volume + 1) / 10.0;
}

double NormalizeVolatility(double volatility) {
    return volatility * 100.0;
}

double CalculateMovingAverage(const double& data[], int period) {
    if (period <= 0 || period > ArraySize(data)) {
        return 0.0;
    }
    
    double sum = 0.0;
    for (int i = 0; i < period; i++) {
        sum += data[i];
    }
    return sum / period;
}

double CalculateRSI(const double& data[], int period) {
    if (period <= 0 || period >= ArraySize(data)) {
        return 50.0;
    }
    
    double gains = 0.0;
    double losses = 0.0;
    
    for (int i = 1; i < period; i++) {
        double change = data[i-1] - data[i];
        if (change > 0) {
            gains += change;
        } else {
            losses += MathAbs(change);
        }
    }
    
    if (losses == 0.0) {
        return 100.0;
    }
    
    double rs = gains / losses;
    return 100.0 - (100.0 / (1.0 + rs));
}

double CalculateMACD(const double& data[]) {
    double ema12 = CalculateEMA(data, 12);
    double ema26 = CalculateEMA(data, 26);
    return ema12 - ema26;
}

double CalculateEMA(const double& data[], int period) {
    if (period <= 0 || period > ArraySize(data)) {
        return 0.0;
    }
    
    double alpha = 2.0 / (period + 1);
    double ema = data[ArraySize(data) - 1];
    
    for (int i = ArraySize(data) - 2; i >= 0; i--) {
        ema = alpha * data[i] + (1 - alpha) * ema;
    }
    
    return ema;
}

double CalculateBollingerBands(const double& data[]) {
    double sma = CalculateMovingAverage(data, 20);
    double stdDev = CalculateStandardDeviation(data, 20);
    
    double upperBand = sma + 2 * stdDev;
    double lowerBand = sma - 2 * stdDev;
    
    if (data[0] > upperBand) {
        return 1.0;
    } else if (data[0] < lowerBand) {
        return -1.0;
    } else {
        return 0.0;
    }
}

double CalculateStandardDeviation(const double& data[], int period) {
    if (period <= 0 || period > ArraySize(data)) {
        return 0.0;
    }
    
    double mean = CalculateMovingAverage(data, period);
    double sumSquares = 0.0;
    
    for (int i = 0; i < period; i++) {
        double diff = data[i] - mean;
        sumSquares += diff * diff;
    }
    
    return MathSqrt(sumSquares / period);
}

double CalculateVolumeMA(const double& data[], int period) {
    return CalculateMovingAverage(data, period);
}

double CalculateVolatility(const double& data[], int period) {
    return CalculateStandardDeviation(data, period) / CalculateMovingAverage(data, period);
}

double CalculateSupport(const double& data[], int period) {
    double minPrice = data[0];
    for (int i = 1; i < period && i < ArraySize(data); i++) {
        if (data[i] < minPrice) {
            minPrice = data[i];
        }
    }
    return minPrice;
}

double CalculateResistance(const double& data[], int period) {
    double maxPrice = data[0];
    for (int i = 1; i < period && i < ArraySize(data); i++) {
        if (data[i] > maxPrice) {
            maxPrice = data[i];
        }
    }
    return maxPrice;
}

void RunNeuralNetwork(const double& inputs[]) {
    // Forward propagation
    for (int i = 0; i < network.hiddenSize; i++) {
        double sum = network.biases[i];
        for (int j = 0; j < network.inputSize; j++) {
            sum += inputs[j] * network.weights[i][j];
        }
        network.neurons[i] = 1.0 / (1.0 + MathExp(-sum)); // Sigmoid activation
    }
    
    // Output layer
    for (int i = 0; i < network.outputSize; i++) {
        double sum = 0.0;
        for (int j = 0; j < network.hiddenSize; j++) {
            sum += network.neurons[j] * network.weights[network.hiddenSize + i][j];
        }
        network.neurons[network.hiddenSize + i] = 1.0 / (1.0 + MathExp(-sum));
    }
}

bool PassMLFilter(ENUM_SIGNAL_DIRECTION signal) {
    // Advanced ML filter logic
    double marketScore = 0.0;
    
    // Score based on trend alignment
    if (signal == market.trend) {
        marketScore += 0.3;
    }
    
    // Score based on volatility
    if (market.volatility > 0.01 && market.volatility < 0.05) {
        marketScore += 0.2;
    }
    
    // Score based on momentum
    if (MathAbs(market.momentum) > 0.001) {
        marketScore += 0.2;
    }
    
    // Score based on volume
    if (volumeData[0] > CalculateVolumeMA(volumeData, 10)) {
        marketScore += 0.3;
    }
    
    return marketScore > 0.6;
}

bool PassCorrelationFilter(ENUM_SIGNAL_DIRECTION signal) {
    // Check correlation with major pairs
    // This is a simplified implementation
    return true;
}

bool PassNewsFilter() {
    // Check for high-impact news
    // This would require news feed integration
    return true;
}

bool PassMultiTimeframeFilter(ENUM_SIGNAL_DIRECTION signal) {
    // Check signal alignment across timeframes
    // This is a simplified implementation
    return true;
}

bool PassVolumeFilter(ENUM_SIGNAL_DIRECTION signal) {
    // Check volume confirmation
    double currentVolume = volumeData[0];
    double avgVolume = CalculateVolumeMA(volumeData, 10);
    
    return currentVolume > avgVolume * 1.2;
}
