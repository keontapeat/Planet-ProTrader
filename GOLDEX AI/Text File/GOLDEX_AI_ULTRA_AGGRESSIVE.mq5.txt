
//+------------------------------------------------------------------+
//| GOLDEX_AI_ULTRA_AGGRESSIVE.mq5                                   |
//| Copyright 2025, xAI                                             |
//| Ultra-aggressive trading system with AI-driven signals           |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, xAI"
#property link      "https://x.ai"
#property version   "1.9"
#property strict

//--- Input Parameters
input double RiskPercentage = 5.0;           // Risk Percentage per Trade
input int TradeFrequencySeconds = 300;       // Trade Frequency (seconds)
input bool EnableMartingale = false;         // Enable Martingale
input double MartingaleMultiplier = 2.0;     // Martingale Multiplier
input bool EnableProgressiveRisk = true;     // Enable Progressive Risk
input double MaxRiskPercentage = 10.0;       // Max Risk Percentage
input bool EnableNotifications = true;       // Enable Notifications

//--- Global Variables
double CurrentMultiplier = 1.0;
int TotalTrades = 0;
int WinningTrades = 0;
int ConsecutiveWins = 0;
int ConsecutiveLosses = 0;
double MaxDrawdown = 0.0;
double InitialBalance = 0.0;
double AccountBalance = 0.0;
double WinRate = 0.0;
struct MarketState {
   bool inUptrend;
   bool inDowntrend;
   bool inRange;
   double volatility;
   double momentum;
   double strength;
   double opportunity;
};
MarketState marketState;
struct TradeStats {
   int totalTrades;
   int winningTrades;
   int losingTrades;
   double winRate;
   int maxConsecutiveWins;
   int maxConsecutiveLosses;
   double maxDrawdown;
   double recovery;
};
TradeStats stats;
enum UltraAggressiveSignalDirection {
   SIGNAL_NONE,
   SIGNAL_BUY,
   SIGNAL_SELL,
   SIGNAL_SCALP_BUY,
   SIGNAL_SCALP_SELL
};
struct UltraAggressiveSignal {
   UltraAggressiveSignalDirection direction;
   double confidence;
   bool isScalp;
   ENUM_TIMEFRAMES timeframe;
   datetime signalTime;
   double entryPrice;
   double stopLoss;
   double takeProfit;
   double lotSize;
   double riskReward;
   double expectedProfit;
   double urgency;
   string signalReason;
};
int RSI_Handle, MACD_Handle, MA_Handle_5, MA_Handle_20, MA_Handle_50, BB_Handle, ATR_Handle;

//+------------------------------------------------------------------+
//| Expert Initialization                                            |
//+------------------------------------------------------------------+
int OnInit()
{
   InitialBalance = AccountBalance();
   EventSetTimer(300); // Update every 5 minutes
   RSI_Handle = iRSI(Symbol(), PERIOD_CURRENT, 14);
   MACD_Handle = iMACD(Symbol(), PERIOD_CURRENT, 12, 26, 9);
   MA_Handle_5 = iMA(Symbol(), PERIOD_CURRENT, 5, 0, MODE_SMA, PRICE_CLOSE);
   MA_Handle_20 = iMA(Symbol(), PERIOD_CURRENT, 20, 0, MODE_SMA, PRICE_CLOSE);
   MA_Handle_50 = iMA(Symbol(), PERIOD_CURRENT, 50, 0, MODE_SMA, PRICE_CLOSE);
   BB_Handle = iBands(Symbol(), PERIOD_CURRENT, 20, 2, 0, PRICE_CLOSE);
   ATR_Handle = iATR(Symbol(), PERIOD_CURRENT, 14);
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert Deinitialization                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   EventKillTimer();
   IndicatorRelease(RSI_Handle);
   IndicatorRelease(MACD_Handle);
   IndicatorRelease(MA_Handle_5);
   IndicatorRelease(MA_Handle_20);
   IndicatorRelease(MA_Handle_50);
   IndicatorRelease(BB_Handle);
   IndicatorRelease(ATR_Handle);
}

//+------------------------------------------------------------------+
//| Expert Timer                                                     |
//+------------------------------------------------------------------+
void OnTimer()
{
   UpdateStats();
   UpdateMarketState();
   UpdateIntelligenceScore();
}

//+------------------------------------------------------------------+
//| Update Market State                                              |
//+------------------------------------------------------------------+
void UpdateMarketState()
{
   double currentPrice = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
   double ma20[], ma50[], atr[];
   
   ArraySetAsSeries(ma20, true);
   ArraySetAsSeries(ma50, true);
   ArraySetAsSeries(atr, true);
   
   if(CopyBuffer(MA_Handle_20, 0, 0, 3, ma20) > 0 &&
      CopyBuffer(MA_Handle_50, 0, 0, 3, ma50) > 0 &&
      CopyBuffer(ATR_Handle, 0, 0, 3, atr) > 0)
   {
      marketState.inUptrend = (currentPrice > ma20[0] && ma20[0] > ma50[0]);
      marketState.inDowntrend = (currentPrice < ma20[0] && ma20[0] < ma50[0]);
      marketState.inRange = (!marketState.inUptrend && !marketState.inDowntrend);
      marketState.volatility = atr[0];
      marketState.momentum = (currentPrice - ma20[0]) / ma20[0] * 100;
      marketState.strength = MathAbs(marketState.momentum);
      marketState.opportunity = marketState.strength * (marketState.volatility * 1000);
      
      if(marketState.volatility > atr[1] * 1.5)
      {
         TradeFrequencySeconds = MathMax(30, TradeFrequencySeconds * 0.8);
      }
      else
      {
         TradeFrequencySeconds = MathMin(600, TradeFrequencySeconds * 1.2);
      }
   }
}

//+------------------------------------------------------------------+
//| Generate Timeframe Signal                                        |
//+------------------------------------------------------------------+
UltraAggressiveSignal GenerateTimeframeSignal(ENUM_TIMEFRAMES timeframe, bool isScalp)
{
   UltraAggressiveSignal signal;
   signal.direction = SIGNAL_NONE;
   signal.confidence = 0.0;
   signal.isScalp = isScalp;
   signal.timeframe = timeframe;
   signal.signalTime = TimeCurrent();
   
   double currentPrice = SymbolInfoDouble(Symbol(), SYMBOL_ASK);
   
   double rsiValue[], macdMain[], macdSignal[], ma5[], ma20[], ma50[], bbUpper[], bbLower[], atr[];
   ArraySetAsSeries(rsiValue, true);
   ArraySetAsSeries(macdMain, true);
   ArraySetAsSeries(macdSignal, true);
   ArraySetAsSeries(ma5, true);
   ArraySetAsSeries(ma20, true);
   ArraySetAsSeries(ma50, true);
   ArraySetAsSeries(bbUpper, true);
   ArraySetAsSeries(bbLower, true);
   ArraySetAsSeries(atr, true);
   
   if(CopyBuffer(RSI_Handle, 0, 0, 3, rsiValue) <= 0) return signal;
   if(CopyBuffer(MACD_Handle, 0, 0, 3, macdMain) <= 0) return signal;
   if(CopyBuffer(MACD_Handle, 1, 0, 3, macdSignal) <= 0) return signal;
   if(CopyBuffer(MA_Handle_5, 0, 0, 3, ma5) <= 0) return signal;
   if(CopyBuffer(MA_Handle_20, 0, 0, 3, ma20) <= 0) return signal;
   if(CopyBuffer(MA_Handle_50, 0, 0, 3, ma50) <= 0) return signal;
   if(CopyBuffer(BB_Handle, 1, 0, 3, bbUpper) <= 0) return signal;
   if(CopyBuffer(BB_Handle, 2, 0, 3, bbLower) <= 0) return signal;
   if(CopyBuffer(ATR_Handle, 0, 0, 3, atr) <= 0) return signal;
   
   double rsi = rsiValue[0];
   double bullishScore = 0.0;
   double bearishScore = 0.0;
   
   if(rsi < 30) bullishScore += 30.0; else if(rsi > 70) bearishScore += 30.0;
   if(rsi > 50 && rsi <= 70) bullishScore += 10.0; else if(rsi < 50 && rsi >= 30) bearishScore += 10.0;
   
   if(currentPrice > ma5[0] && ma5[0] > ma20[0] && ma20[0] > ma50[0]) bullishScore += 25.0;
   else if(currentPrice < ma5[0] && ma5[0] < ma20[0] && ma20[0] < ma50[0]) bearishScore += 25.0;
   
   if(macdMain[0] > macdSignal[0] && macdMain[1] <= macdSignal[1]) bullishScore += 20.0;
   else if(macdMain[0] < macdSignal[0] && macdMain[1] >= macdSignal[1]) bearishScore += 20.0;
   
   if(currentPrice > bbUpper[0]) bullishScore += 15.0; else if(currentPrice < bbLower[0]) bearishScore += 15.0;
   
   if(atr[0] > atr[1] * 1.1) { bullishScore += 10.0; bearishScore += 10.0; }
   
   if(bullishScore > bearishScore && bullishScore >= 50.0)
   {
      signal.direction = isScalp ? SIGNAL_SCALP_BUY : SIGNAL_BUY;
      signal.confidence = bullishScore;
      signal.signalReason = "Bullish " + EnumToString(timeframe) + " signal";
   }
   else if(bearishScore > bullishScore && bearishScore >= 50.0)
   {
      signal.direction = isScalp ? SIGNAL_SCALP_SELL : SIGNAL_SELL;
      signal.confidence = bearishScore;
      signal.signalReason = "Bearish " + EnumToString(timeframe) + " signal";
   }
   
   if(signal.direction != SIGNAL_NONE)
   {
      signal.entryPrice = currentPrice;
      signal.urgency = isScalp ? 95.0 : 75.0;
      signal.stopLoss = CalculateStopLoss(signal.direction, currentPrice);
      signal.takeProfit = CalculateTakeProfit(signal.direction, currentPrice);
      signal.lotSize = CalculateAggressiveLotSize(signal.stopLoss, currentPrice, isScalp);
      signal.riskReward = MathAbs(signal.takeProfit - signal.entryPrice) / MathAbs(signal.entryPrice - signal.stopLoss);
      signal.expectedProfit = signal.lotSize * MathAbs(signal.takeProfit - signal.entryPrice) * 100000;
      ApplyProgressiveProfit(signal);
   }
   
   return signal;
}

//+------------------------------------------------------------------+
//| Generate Multiple Signals                                        |
//+------------------------------------------------------------------+
int GenerateMultipleSignals(UltraAggressiveSignal &signals[])
{
   ArrayResize(signals, 10);
   int count = 0;
   
   UltraAggressiveSignal m1Signal = GenerateTimeframeSignal(PERIOD_M1, true);
   if(m1Signal.direction != SIGNAL_NONE) { signals[count] = m1Signal; count++; }
   
   UltraAggressiveSignal m5Signal = GenerateTimeframeSignal(PERIOD_M5, false);
   if(m5Signal.direction != SIGNAL_NONE) { signals[count] = m5Signal; count++; }
   
   UltraAggressiveSignal m15Signal = GenerateTimeframeSignal(PERIOD_M15, false);
   if(m15Signal.direction != SIGNAL_NONE) { signals[count] = m15Signal; count++; }
   
   return count;
}

//+------------------------------------------------------------------+
//| Calculate Stop Loss                                              |
//+------------------------------------------------------------------+
double CalculateStopLoss(UltraAggressiveSignalDirection direction, double entryPrice)
{
   double atr[];
   ArraySetAsSeries(atr, true);
   if(CopyBuffer(ATR_Handle, 0, 0, 1, atr) > 0)
   {
      return (direction == SIGNAL_BUY || direction == SIGNAL_SCALP_BUY) ? entryPrice - atr[0] * 2 : entryPrice + atr[0] * 2;
   }
   return 0.0;
}

//+------------------------------------------------------------------+
//| Calculate Take Profit                                            |
//+------------------------------------------------------------------+
double CalculateTakeProfit(UltraAggressiveSignalDirection direction, double entryPrice)
{
   double atr[];
   ArraySetAsSeries(atr, true);
   if(CopyBuffer(ATR_Handle, 0, 0, 1, atr) > 0)
   {
      return (direction == SIGNAL_BUY || direction == SIGNAL_SCALP_BUY) ? entryPrice + atr[0] * 4 : entryPrice - atr[0] * 4;
   }
   return 0.0;
}

//+------------------------------------------------------------------+
//| Calculate Aggressive Lot Size                                    |
//+------------------------------------------------------------------+
double CalculateAggressiveLotSize(double stopLoss, double entryPrice, bool isScalp)
{
   double balance = AccountBalance();
   double riskPercent = isScalp ? 3.0 : RiskPercentage;
   
   if(ConsecutiveLosses > 2 && EnableProgressiveRisk)
   {
      riskPercent = MathMin(MaxRiskPercentage, riskPercent * (1.0 + ConsecutiveLosses * 0.3));
   }
   
   if(EnableMartingale && ConsecutiveLosses > 0)
   {
      CurrentMultiplier = MathPow(MartingaleMultiplier, ConsecutiveLosses);
   }
   else
   {
      CurrentMultiplier = 1.0;
   }
   
   double riskAmount = balance * (riskPercent / 100.0) * CurrentMultiplier;
   double stopLossPoints = MathAbs(entryPrice - stopLoss) / SymbolInfoDouble(Symbol(), SYMBOL_POINT);
   double tickValue = SymbolInfoDouble(Symbol(), SYMBOL_TRADE_TICK_VALUE);
   double lotSize = riskAmount / (stopLossPoints * tickValue);
   
   double minLot = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_STEP);
   
   lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
   lotSize = MathRound(lotSize / lotStep) * lotStep;
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Apply Progressive Profit                                         |
//+------------------------------------------------------------------+
void ApplyProgressiveProfit(UltraAggressiveSignal &signal)
{
   if(signal.confidence > 80.0 && signal.riskReward < 2.0)
   {
      signal.takeProfit += (signal.takeProfit - signal.entryPrice) * 0.5;
      signal.riskReward = MathAbs(signal.takeProfit - signal.entryPrice) / MathAbs(signal.entryPrice - signal.stopLoss);
   }
}

//+------------------------------------------------------------------+
//| Update Stats                                                     |
//+------------------------------------------------------------------+
void UpdateStats()
{
   AccountBalance = AccountBalance();
   stats.totalTrades = TotalTrades;
   stats.winningTrades = WinningTrades;
   stats.losingTrades = TotalTrades - WinningTrades;
   stats.winRate = TotalTrades > 0 ? (double)WinningTrades / TotalTrades : 0.0;
   stats.maxConsecutiveWins = MathMax(stats.maxConsecutiveWins, ConsecutiveWins);
   stats.maxConsecutiveLosses = MathMax(stats.maxConsecutiveLosses, ConsecutiveLosses);
   double currentDrawdown = (InitialBalance - AccountEquity()) / InitialBalance * 100.0;
   stats.maxDrawdown = MathMax(stats.maxDrawdown, currentDrawdown);
   stats.recovery = (AccountBalance - InitialBalance) / InitialBalance * 100.0;
   
   if(stats.winRate < 0.5 && ConsecutiveLosses > 2)
   {
      RiskPercentage = MathMax(1.0, RiskPercentage * 0.9);
      Print("🔄 Adjusting RiskPercentage to ", RiskPercentage, " due to poor performance");
   }
   else if(stats.winRate > 0.7 && ConsecutiveWins > 2)
   {
      RiskPercentage = MathMin(10.0, RiskPercentage * 1.1);
      Print("🔥 Increasing RiskPercentage to ", RiskPercentage, " due to strong performance");
   }
}

//+------------------------------------------------------------------+
//| Update Intelligence Score                                        |
//+------------------------------------------------------------------+
void UpdateIntelligenceScore()
{
   double baseScore = 75.0;
   double winRateBonus = (stats.winRate - 0.5) * 50.0;
   double consecutiveBonus = MathMin(ConsecutiveWins * 2.0, 10.0);
   double newScore = baseScore + winRateBonus + consecutiveBonus;
   double intelligenceScore = MathMax(0.0, MathMin(100.0, newScore));
   
   if(MathAbs(intelligenceScore - 75.0) > 1.0)
   {
      Print("🧠 Intelligence Score Updated: ", DoubleToString(intelligenceScore, 2));
   }
}

//+------------------------------------------------------------------+
//| Expert Tick Function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   static datetime lastTradeTime = 0;
   if(TimeCurrent() - lastTradeTime < TradeFrequencySeconds) return;
   
   UltraAggressiveSignal signals[];
   int signalCount = GenerateMultipleSignals(signals);
   
   for(int i = 0; i < signalCount; i++)
   {
      if(signals[i].direction != SIGNAL_NONE && signals[i].confidence > 60.0)
      {
         if(ExecuteTrade(signals[i]))
         {
            lastTradeTime = TimeCurrent();
            break;
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Execute Trade                                                    |
//+------------------------------------------------------------------+
bool ExecuteTrade(UltraAggressiveSignal &signal)
{
   if(signal.direction == SIGNAL_BUY || signal.direction == SIGNAL_SCALP_BUY)
   {
      CTrade trade;
      if(trade.Buy(signal.lotSize, Symbol(), signal.entryPrice, signal.stopLoss, signal.takeProfit))
      {
         TotalTrades++;
         ConsecutiveWins++;
         ConsecutiveLosses = 0;
         WinningTrades++;
         if(EnableNotifications) SendNotification("BUY executed: " + signal.signalReason);
         return true;
      }
      ConsecutiveLosses++;
      ConsecutiveWins = 0;
   }
   else if(signal.direction == SIGNAL_SELL || signal.direction == SIGNAL_SCALP_SELL)
   {
      CTrade trade;
      if(trade.Sell(signal.lotSize, Symbol(), signal.entryPrice, signal.stopLoss, signal.takeProfit))
      {
         TotalTrades++;
         ConsecutiveWins++;
         ConsecutiveLosses = 0;
         WinningTrades++;
         if(EnableNotifications) SendNotification("SELL executed: " + signal.signalReason);
         return true;
      }
      ConsecutiveLosses++;
      ConsecutiveWins = 0;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Include Trade Class                                              |
//+------------------------------------------------------------------+
#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
