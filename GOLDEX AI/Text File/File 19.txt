//+------------------------------------------------------------------+
//|                                    GOLDEX_AI_ULTRA_AGGRESSIVE.mq5 |
//|                                  Copyright 2024, GOLDEX AI Team |
//|                                             https://goldexai.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, GOLDEX AI Team"
#property link      "https://goldexai.com"
#property version   "8.00"
#property strict

#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\AccountInfo.mqh>

CTrade trade;
CPositionInfo position;
CAccountInfo account;

//--- Input Parameters (Set to your preferred defaults)
input group "=== FLIP MODE SETTINGS ==="
input ENUM_TIMEFRAMES FlipTimeframe = PERIOD_M1;
input double FlipRiskPercent = 5.0;
input double FlipTargetPercent = 10.0;
input bool EnableFlipMode = true;
input bool EnableScalpMode = true;
input bool EnableAggressiveMode = true;

input group "=== RISK MANAGEMENT ==="
input double RiskPercentage = 8.0;
input double MaxRiskPercentage = 8.0;
input double StopLossPoints = 35.0;
input double TakeProfitPoints = 550.0;
input double TrailingStopPoints = 0.0;

input group "=== TRADING SETTINGS ==="
input bool EnableAutoTrading = true;
input bool EnableNotifications = true;
input bool EnableSoundAlerts = false;
input int MagicNumber = 123456;
input string TradeComment = "GOLDEX_AI_FLIP";

input group "=== AI ENHANCEMENT ==="
input bool EnableAILearning = true;
input bool EnableSmartEntry = true;
input bool EnableDynamicSizing = true;
input bool EnableMultiTimeframe = true;

input group "=== ULTRA AGGRESSIVE MODE ==="
input bool EnableUltraAggressive = true;
input int MaxSimultaneousPositions = 5;
input double ScalpProfitPoints = 10.0;
input double QuickExitPoints = 5.0;
input int MinSecondsBetweenTrades = 5;
input bool EnableInstantScalping = true;
input bool EnableHedging = true;
input bool EnableMartingale = false;
input double MartingaleMultiplier = 1.5;

//--- Global Variables
double AccountBalance = 0.0;
double InitialBalance = 0.0;
double CurrentDrawdown = 0.0;
double MaxDrawdown = 0.0;
double DailyTarget = 0.0;
double WeeklyTarget = 0.0;
int TotalTrades = 0;
int WinningTrades = 0;
double WinRate = 0.0;
bool FlipModeActive = false;
datetime LastTradeTime = 0;
double LastPrice = 0.0;
string Symbol = "";
int ConsecutiveLosses = 0;
double CurrentMultiplier = 1.0;
bool AlwaysInTrade = false;

//--- Arrays for multiple position tracking
ulong PositionTickets[];
datetime PositionOpenTimes[];
double PositionProfits[];
int ActivePositions = 0;

//--- Indicator Handles
int RSI_Handle;
int MACD_Handle;
int MA_Handle_5;
int MA_Handle_20;
int MA_Handle_50;
int ATR_Handle;
int BB_Handle;
int MOM_Handle;

//--- Enums
enum ENUM_ULTRA_MODE
{
   ULTRA_CONSERVATIVE,
   ULTRA_MODERATE,
   ULTRA_AGGRESSIVE,
   ULTRA_INSANE,
   ULTRA_SCALP_MASTER
};

enum ENUM_SIGNAL_TYPE
{
   SIGNAL_NONE,
   SIGNAL_BUY,
   SIGNAL_SELL,
   SIGNAL_CLOSE_BUY,
   SIGNAL_CLOSE_SELL,
   SIGNAL_SCALP_BUY,
   SIGNAL_SCALP_SELL,
   SIGNAL_HEDGE_BUY,
   SIGNAL_HEDGE_SELL
};

//--- Structures
struct UltraAggressiveSignal
{
   ENUM_SIGNAL_TYPE direction;
   double entryPrice;
   double stopLoss;
   double takeProfit;
   double lotSize;
   double confidence;
   double urgency;
   bool isScalp;
   bool isHedge;
   int timeframe;
   double expectedProfit;
   string signalReason;
};

struct TradingState
{
   bool inUptrend;
   bool inDowntrend;
   bool inRange;
   double volatility;
   double momentum;
   double strength;
   double opportunity;
};

//--- Global Objects
UltraAggressiveSignal currentSignal;
TradingState marketState;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   Symbol = _Symbol;
   AccountBalance = account.Balance();
   InitialBalance = AccountBalance;
   
   // Initialize indicator handles
   RSI_Handle = iRSI(Symbol, PERIOD_M15, 14, PRICE_CLOSE);
   MACD_Handle = iMACD(Symbol, PERIOD_M15, 12, 26, 9, PRICE_CLOSE);
   MA_Handle_5 = iMA(Symbol, PERIOD_M15, 5, 0, MODE_EMA, PRICE_CLOSE);
   MA_Handle_20 = iMA(Symbol, PERIOD_M15, 20, 0, MODE_EMA, PRICE_CLOSE);
   MA_Handle_50 = iMA(Symbol, PERIOD_M15, 50, 0, MODE_EMA, PRICE_CLOSE);
   ATR_Handle = iATR(Symbol, PERIOD_M15, 14);
   BB_Handle = iBands(Symbol, PERIOD_M5, 20, 0, 2, PRICE_CLOSE);
   MOM_Handle = iMomentum(Symbol, PERIOD_M1, 10, PRICE_CLOSE);
   
   // Check if all handles are valid
   if(RSI_Handle == INVALID_HANDLE || MACD_Handle == INVALID_HANDLE || 
      MA_Handle_5 == INVALID_HANDLE || MA_Handle_20 == INVALID_HANDLE || 
      MA_Handle_50 == INVALID_HANDLE || ATR_Handle == INVALID_HANDLE ||
      BB_Handle == INVALID_HANDLE || MOM_Handle == INVALID_HANDLE)
   {
      Print("Error creating indicator handles");
      return(INIT_FAILED);
   }
   
   // Initialize arrays
   ArrayResize(PositionTickets, MaxSimultaneousPositions);
   ArrayResize(PositionOpenTimes, MaxSimultaneousPositions);
   ArrayResize(PositionProfits, MaxSimultaneousPositions);
   
   // Set up ultra aggressive mode
   if(EnableUltraAggressive)
   {
      SetupUltraAggressiveMode();
   }
   
   // Set up flip mode targets
   if(EnableFlipMode)
   {
      SetupFlipModeTargets();
   }
   
   // Enable always in trade mode
   AlwaysInTrade = EnableUltraAggressive;
   
   Print("ðŸš€ GOLDEX AI ULTRA AGGRESSIVE EA Initialized");
   Print("ðŸ’° Account Balance: $", AccountBalance);
   Print("ðŸŽ¯ Target: $1,000 â†’ $100,000");
   Print("âš¡ Ultra Aggressive Mode: ", EnableUltraAggressive ? "ENABLED" : "DISABLED");
   Print("ðŸ”¥ Max Simultaneous Positions: ", MaxSimultaneousPositions);
   Print("ðŸ’¨ Instant Scalping: ", EnableInstantScalping ? "ENABLED" : "DISABLED");
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                               |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // Release indicator handles
   if(RSI_Handle != INVALID_HANDLE) IndicatorRelease(RSI_Handle);
   if(MACD_Handle != INVALID_HANDLE) IndicatorRelease(MACD_Handle);
   if(MA_Handle_5 != INVALID_HANDLE) IndicatorRelease(MA_Handle_5);
   if(MA_Handle_20 != INVALID_HANDLE) IndicatorRelease(MA_Handle_20);
   if(MA_Handle_50 != INVALID_HANDLE) IndicatorRelease(MA_Handle_50);
   if(ATR_Handle != INVALID_HANDLE) IndicatorRelease(ATR_Handle);
   if(BB_Handle != INVALID_HANDLE) IndicatorRelease(BB_Handle);
   if(MOM_Handle != INVALID_HANDLE) IndicatorRelease(MOM_Handle);
   
   Print("GOLDEX AI ULTRA AGGRESSIVE EA Deinitialized. Reason: ", reason);
   SaveUltraAggressiveStats();
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!EnableAutoTrading) return;
   
   // Update account and market state
   UpdateAccountInfo();
   UpdateMarketState();
   
   // Ultra aggressive trading logic
   if(EnableUltraAggressive)
   {
      ExecuteUltraAggressiveStrategy();
   }
   
   // Regular flip mode trading
   if(EnableFlipMode)
   {
      ExecuteFlipModeStrategy();
   }
   
   // Scalping logic
   if(EnableScalpMode || EnableInstantScalping)
   {
      ExecuteScalpingStrategy();
   }
   
   // Manage all positions
   ManageAllPositions();
   
   // Ensure always in trade if enabled
   if(AlwaysInTrade && ActivePositions == 0)
   {
      ForceTradeEntry();
   }
   
   // Update position tracking
   UpdatePositionTracking();
}

//+------------------------------------------------------------------+
//| Setup Ultra Aggressive Mode                                     |
//+------------------------------------------------------------------+
void SetupUltraAggressiveMode()
{
   // Configure for maximum aggression
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetDeviationInPoints(10);
   trade.SetTypeFilling(ORDER_FILLING_IOC);
   
   Print("ðŸ”¥ Ultra Aggressive Mode Configured");
   Print("âš¡ Max Positions: ", MaxSimultaneousPositions);
   Print("ðŸ’¨ Scalp Profit: ", ScalpProfitPoints, " points");
   Print("ðŸŽ¯ Quick Exit: ", QuickExitPoints, " points");
}

//+------------------------------------------------------------------+
//| Execute Ultra Aggressive Strategy                               |
//+------------------------------------------------------------------+
void ExecuteUltraAggressiveStrategy()
{
   // Generate multiple signals simultaneously
   UltraAggressiveSignal signals[];
   int signalCount = GenerateMultipleSignals(signals);
   
   // Execute up to max simultaneous positions
   for(int i = 0; i < signalCount && ActivePositions < MaxSimultaneousPositions; i++)
   {
      if(signals[i].confidence > 60.0)
      {
         ExecuteUltraSignal(signals[i]);
      }
   }
   
   // Check for immediate scalping opportunities
   if(EnableInstantScalping)
   {
      CheckInstantScalpingOpportunity();
   }
   
   // Hedging logic
   if(EnableHedging && ActivePositions > 0)
   {
      CheckHedgingOpportunity();
   }
}

//+------------------------------------------------------------------+
//| Generate Multiple Signals                                        |
//+------------------------------------------------------------------+
int GenerateMultipleSignals(UltraAggressiveSignal &signals[])
{
   ArrayResize(signals, 10);
   int count = 0;
   
   // M1 Scalping Signal
   UltraAggressiveSignal m1Signal = GenerateTimeframeSignal(PERIOD_M1, true);
   if(m1Signal.direction != SIGNAL_NONE)
   {
      signals[count] = m1Signal;
      count++;
   }
   
   // M5 Quick Signal
   UltraAggressiveSignal m5Signal = GenerateTimeframeSignal(PERIOD_M5, false);
   if(m5Signal.direction != SIGNAL_NONE)
   {
      signals[count] = m5Signal;
      count++;
   }
   
   // M15 Trend Signal
   UltraAggressiveSignal m15Signal = GenerateTimeframeSignal(PERIOD_M15, false);
   if(m15Signal.direction != SIGNAL_NONE)
   {
      signals[count] = m15Signal;
      count++;
   }
   
   // Volatility Breakout Signal
   UltraAggressiveSignal volatilitySignal = GenerateVolatilitySignal();
   if(volatilitySignal.direction != SIGNAL_NONE)
   {
      signals[count] = volatilitySignal;
      count++;
   }
   
   // Momentum Signal
   UltraAggressiveSignal momentumSignal = GenerateMomentumSignal();
   if(momentumSignal.direction != SIGNAL_NONE)
   {
      signals[count] = momentumSignal;
      count++;
   }
   
   return count;
}

//+------------------------------------------------------------------+
//| Generate Timeframe Signal                                        |
//+------------------------------------------------------------------+
UltraAggressiveSignal GenerateTimeframeSignal(ENUM_TIMEFRAMES timeframe, bool isScalp)
{
   UltraAggressiveSignal signal;
   signal.direction = SIGNAL_NONE;
   signal.confidence = 0.0;
   signal.isScalp = isScalp;
   signal.timeframe = timeframe;
   
   double currentPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   
   // Get indicator values using handles
   double rsiValue[];
   double macdMain[], macdSignal[];
   double ma5[], ma20[], ma50[];
   
   ArraySetAsSeries(rsiValue, true);
   ArraySetAsSeries(macdMain, true);
   ArraySetAsSeries(macdSignal, true);
   ArraySetAsSeries(ma5, true);
   ArraySetAsSeries(ma20, true);
   ArraySetAsSeries(ma50, true);
   
   // Copy indicator data
   if(CopyBuffer(RSI_Handle, 0, 0, 3, rsiValue) <= 0) return signal;
   if(CopyBuffer(MACD_Handle, 0, 0, 3, macdMain) <= 0) return signal;
   if(CopyBuffer(MACD_Handle, 1, 0, 3, macdSignal) <= 0) return signal;
   if(CopyBuffer(MA_Handle_5, 0, 0, 3, ma5) <= 0) return signal;
   if(CopyBuffer(MA_Handle_20, 0, 0, 3, ma20) <= 0) return signal;
   if(CopyBuffer(MA_Handle_50, 0, 0, 3, ma50) <= 0) return signal;
   
   double rsi = rsiValue[0];
   
   // Signal Logic
   double bullishScore = 0.0;
   double bearishScore = 0.0;
   
   // RSI scoring
   if(rsi < 30) bullishScore += 30.0;
   if(rsi > 70) bearishScore += 30.0;
   if(rsi > 50 && rsi < 70) bullishScore += 10.0;
   if(rsi < 50 && rsi > 30) bearishScore += 10.0;
   
   // MA scoring
   if(currentPrice > ma5[0] && ma5[0] > ma20[0] && ma20[0] > ma50[0]) bullishScore += 25.0;
   if(currentPrice < ma5[0] && ma5[0] < ma20[0] && ma20[0] < ma50[0]) bearishScore += 25.0;
   
   // MACD scoring
   if(macdMain[0] > macdSignal[0] && macdMain[1] <= macdSignal[1]) bullishScore += 20.0;
   if(macdMain[0] < macdSignal[0] && macdMain[1] >= macdSignal[1]) bearishScore += 20.0;
   
   // Price action scoring
   double priceChange = (currentPrice - ma20[0]) / ma20[0] * 100;
   if(priceChange > 0.1) bullishScore += 15.0;
   if(priceChange < -0.1) bearishScore += 15.0;
   
   // Determine signal
   if(bullishScore > bearishScore && bullishScore >= 50.0)
   {
      signal.direction = isScalp ? SIGNAL_SCALP_BUY : SIGNAL_BUY;
      signal.confidence = bullishScore;
      signal.signalReason = "Bullish " + EnumToString(timeframe) + " signal";
   }
   else if(bearishScore > bullishScore && bearishScore >= 50.0)
   {
      signal.direction = isScalp ? SIGNAL_SCALP_SELL : SIGNAL_SELL;
      signal.confidence = bearishScore;
      signal.signalReason = "Bearish " + EnumToString(timeframe) + " signal";
   }
   
   // Set signal parameters
   if(signal.direction != SIGNAL_NONE)
   {
      signal.entryPrice = currentPrice;
      signal.urgency = isScalp ? 95.0 : 75.0;
      
      if(isScalp)
      {
         signal.stopLoss = CalculateScalpStopLoss(signal.direction, currentPrice);
         signal.takeProfit = CalculateScalpTakeProfit(signal.direction, currentPrice);
      }
      else
      {
         signal.stopLoss = CalculateStopLoss(signal.direction, currentPrice);
         signal.takeProfit = CalculateTakeProfit(signal.direction, currentPrice);
      }
      
      signal.lotSize = CalculateAggressiveLotSize(signal.stopLoss, currentPrice, isScalp);
      signal.expectedProfit = signal.lotSize * MathAbs(signal.takeProfit - signal.entryPrice) * 100000;
   }
   
   return signal;
}

//+------------------------------------------------------------------+
//| Generate Volatility Signal                                       |
//+------------------------------------------------------------------+
UltraAggressiveSignal GenerateVolatilitySignal()
{
   UltraAggressiveSignal signal;
   signal.direction = SIGNAL_NONE;
   signal.confidence = 0.0;
   signal.signalReason = "Volatility Breakout";
   
   double currentPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   
   // Get ATR and Bollinger Bands values
   double atrValue[];
   double bbUpper[], bbLower[];
   
   ArraySetAsSeries(atrValue, true);
   ArraySetAsSeries(bbUpper, true);
   ArraySetAsSeries(bbLower, true);
   
   if(CopyBuffer(ATR_Handle, 0, 0, 3, atrValue) <= 0) return signal;
   if(CopyBuffer(BB_Handle, 1, 0, 3, bbUpper) <= 0) return signal;
   if(CopyBuffer(BB_Handle, 2, 0, 3, bbLower) <= 0) return signal;
   
   double atr = atrValue[0];
   
   // Volatility breakout logic
   if(currentPrice > bbUpper[0])
   {
      signal.direction = SIGNAL_BUY;
      signal.confidence = 80.0;
      signal.urgency = 90.0;
   }
   else if(currentPrice < bbLower[0])
   {
      signal.direction = SIGNAL_SELL;
      signal.confidence = 80.0;
      signal.urgency = 90.0;
   }
   
   if(signal.direction != SIGNAL_NONE)
   {
      signal.entryPrice = currentPrice;
      signal.stopLoss = CalculateVolatilityStopLoss(signal.direction, currentPrice, atr);
      signal.takeProfit = CalculateVolatilityTakeProfit(signal.direction, currentPrice, atr);
      signal.lotSize = CalculateAggressiveLotSize(signal.stopLoss, currentPrice, false);
      signal.expectedProfit = signal.lotSize * MathAbs(signal.takeProfit - signal.entryPrice) * 100000;
   }
   
   return signal;
}

//+------------------------------------------------------------------+
//| Generate Momentum Signal                                         |
//+------------------------------------------------------------------+
UltraAggressiveSignal GenerateMomentumSignal()
{
   UltraAggressiveSignal signal;
   signal.direction = SIGNAL_NONE;
   signal.confidence = 0.0;
   signal.signalReason = "Momentum Surge";
   
   double currentPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   
   // Get momentum values
   double momValue[];
   ArraySetAsSeries(momValue, true);
   
   if(CopyBuffer(MOM_Handle, 0, 0, 3, momValue) <= 0) return signal;
   
   double mom = momValue[0];
   
   // Get price data for ROC calculation
   double priceData[];
   ArraySetAsSeries(priceData, true);
   
   if(CopyClose(Symbol, PERIOD_M1, 0, 10, priceData) <= 0) return signal;
   
   // Price rate of change
   double priceROC = (priceData[0] - priceData[5]) / priceData[5] * 100;
   
   // Momentum surge detection
   if(mom > 100.05 && priceROC > 0.02)
   {
      signal.direction = SIGNAL_BUY;
      signal.confidence = 85.0;
      signal.urgency = 95.0;
   }
   else if(mom < 99.95 && priceROC < -0.02)
   {
      signal.direction = SIGNAL_SELL;
      signal.confidence = 85.0;
      signal.urgency = 95.0;
   }
   
   if(signal.direction != SIGNAL_NONE)
   {
      signal.entryPrice = currentPrice;
      signal.stopLoss = CalculateMomentumStopLoss(signal.direction, currentPrice);
      signal.takeProfit = CalculateMomentumTakeProfit(signal.direction, currentPrice);
      signal.lotSize = CalculateAggressiveLotSize(signal.stopLoss, currentPrice, false);
      signal.expectedProfit = signal.lotSize * MathAbs(signal.takeProfit - signal.entryPrice) * 100000;
   }
   
   return signal;
}

//+------------------------------------------------------------------+
//| Execute Ultra Signal                                             |
//+------------------------------------------------------------------+
void ExecuteUltraSignal(UltraAggressiveSignal &signal)
{
   if(TimeCurrent() - LastTradeTime < MinSecondsBetweenTrades) return;
   
   bool success = false;
   ulong ticket = 0;
   
   // Execute based on signal type
   switch(signal.direction)
   {
      case SIGNAL_BUY:
      case SIGNAL_SCALP_BUY:
         success = trade.Buy(signal.lotSize, Symbol, signal.entryPrice, signal.stopLoss, signal.takeProfit, TradeComment + "_" + signal.signalReason);
         ticket = trade.ResultOrder();
         break;
         
      case SIGNAL_SELL:
      case SIGNAL_SCALP_SELL:
         success = trade.Sell(signal.lotSize, Symbol, signal.entryPrice, signal.stopLoss, signal.takeProfit, TradeComment + "_" + signal.signalReason);
         ticket = trade.ResultOrder();
         break;
   }
   
   if(success && ticket > 0)
   {
      // Add to position tracking
      if(ActivePositions < MaxSimultaneousPositions)
      {
         PositionTickets[ActivePositions] = ticket;
         PositionOpenTimes[ActivePositions] = TimeCurrent();
         PositionProfits[ActivePositions] = 0.0;
         ActivePositions++;
      }
      
      TotalTrades++;
      LastTradeTime = TimeCurrent();
      
      // Log the trade
      LogUltraAggressiveTrade(signal, ticket);
      
      // Send notification
      if(EnableNotifications)
      {
         SendNotification(CreateUltraNotification(signal));
      }
      
      // Play sound
      if(EnableSoundAlerts)
      {
         PlaySound("alert.wav");
      }
   }
}

//+------------------------------------------------------------------+
//| Check Instant Scalping Opportunity                              |
//+------------------------------------------------------------------+
void CheckInstantScalpingOpportunity()
{
   double currentPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   double bidPrice = SymbolInfoDouble(Symbol, SYMBOL_BID);
   double spread = currentPrice - bidPrice;
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   
   // Very quick scalping based on spread and micro movements
   static double lastScalpPrice = 0.0;
   static datetime lastScalpTime = 0;
   
   if(lastScalpPrice == 0.0)
   {
      lastScalpPrice = currentPrice;
      lastScalpTime = TimeCurrent();
      return;
   }
   
   double priceMove = MathAbs(currentPrice - lastScalpPrice);
   int timeDiff = (int)(TimeCurrent() - lastScalpTime);
   
   // Instant scalp conditions
   if(priceMove >= 3.0 * point && timeDiff >= 1)
   {
      UltraAggressiveSignal scalpSignal;
      scalpSignal.isScalp = true;
      scalpSignal.urgency = 99.0;
      scalpSignal.confidence = 70.0;
      scalpSignal.entryPrice = currentPrice;
      scalpSignal.signalReason = "Instant_Scalp";
      
      if(currentPrice > lastScalpPrice)
      {
         scalpSignal.direction = SIGNAL_SCALP_BUY;
      }
      else
      {
         scalpSignal.direction = SIGNAL_SCALP_SELL;
      }
      
      scalpSignal.stopLoss = CalculateInstantScalpStopLoss(scalpSignal.direction, currentPrice);
      scalpSignal.takeProfit = CalculateInstantScalpTakeProfit(scalpSignal.direction, currentPrice);
      scalpSignal.lotSize = CalculateAggressiveLotSize(scalpSignal.stopLoss, currentPrice, true);
      
      if(ActivePositions < MaxSimultaneousPositions)
      {
         ExecuteUltraSignal(scalpSignal);
      }
      
      lastScalpPrice = currentPrice;
      lastScalpTime = TimeCurrent();
   }
}

//+------------------------------------------------------------------+
//| Check Hedging Opportunity                                        |
//+------------------------------------------------------------------+
void CheckHedgingOpportunity()
{
   if(!EnableHedging) return;
   
   double totalProfit = 0.0;
   int buyPositions = 0;
   int sellPositions = 0;
   
   // Calculate total profit and position balance
   for(int i = 0; i < ActivePositions; i++)
   {
      if(position.SelectByTicket(PositionTickets[i]))
      {
         totalProfit += position.Profit();
         
         if(position.PositionType() == POSITION_TYPE_BUY)
            buyPositions++;
         else if(position.PositionType() == POSITION_TYPE_SELL)
            sellPositions++;
      }
   }
   
   // Hedge if losing and unbalanced
   if(totalProfit < -50.0 && MathAbs(buyPositions - sellPositions) >= 2)
   {
      UltraAggressiveSignal hedgeSignal;
      hedgeSignal.isHedge = true;
      hedgeSignal.confidence = 90.0;
      hedgeSignal.urgency = 85.0;
      hedgeSignal.entryPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
      hedgeSignal.signalReason = "Hedge_Protection";
      
      // Hedge in opposite direction of majority
      if(buyPositions > sellPositions)
      {
         hedgeSignal.direction = SIGNAL_HEDGE_SELL;
      }
      else
      {
         hedgeSignal.direction = SIGNAL_HEDGE_BUY;
      }
      
      hedgeSignal.stopLoss = CalculateHedgeStopLoss(hedgeSignal.direction, hedgeSignal.entryPrice);
      hedgeSignal.takeProfit = CalculateHedgeTakeProfit(hedgeSignal.direction, hedgeSignal.entryPrice);
      hedgeSignal.lotSize = CalculateHedgeLotSize(totalProfit);
      
      if(ActivePositions < MaxSimultaneousPositions)
      {
         ExecuteUltraSignal(hedgeSignal);
      }
   }
}

//+------------------------------------------------------------------+
//| Force Trade Entry                                                |
//+------------------------------------------------------------------+
void ForceTradeEntry()
{
   if(!AlwaysInTrade) return;
   
   // Generate a forced entry signal
   UltraAggressiveSignal forceSignal;
   forceSignal.confidence = 65.0;
   forceSignal.urgency = 80.0;
   forceSignal.entryPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   forceSignal.signalReason = "Force_Entry";
   
   // Get MA20 value
   double ma20[];
   ArraySetAsSeries(ma20, true);
   
   if(CopyBuffer(MA_Handle_20, 0, 0, 3, ma20) > 0)
   {
      double currentPrice = forceSignal.entryPrice;
      
      if(currentPrice > ma20[0])
      {
         forceSignal.direction = SIGNAL_BUY;
      }
      else
      {
         forceSignal.direction = SIGNAL_SELL;
      }
      
      forceSignal.stopLoss = CalculateStopLoss(forceSignal.direction, currentPrice);
      forceSignal.takeProfit = CalculateTakeProfit(forceSignal.direction, currentPrice);
      forceSignal.lotSize = CalculateAggressiveLotSize(forceSignal.stopLoss, currentPrice, false);
      
      ExecuteUltraSignal(forceSignal);
   }
}

//+------------------------------------------------------------------+
//| Calculate Aggressive Lot Size                                    |
//+------------------------------------------------------------------+
double CalculateAggressiveLotSize(double stopLoss, double entryPrice, bool isScalp)
{
   double balance = account.Balance();
   double riskPercent = isScalp ? 3.0 : RiskPercentage;
   
   // Apply martingale if enabled
   if(EnableMartingale && ConsecutiveLosses > 0)
   {
      CurrentMultiplier = MathPow(MartingaleMultiplier, ConsecutiveLosses);
   }
   else
   {
      CurrentMultiplier = 1.0;
   }
   
   double riskAmount = balance * (riskPercent / 100.0) * CurrentMultiplier;
   double stopLossPoints = MathAbs(entryPrice - stopLoss);
   double tickValue = SymbolInfoDouble(Symbol, SYMBOL_TRADE_TICK_VALUE);
   double lotSize = riskAmount / (stopLossPoints * tickValue * 100000);
   
   // Normalize lot size
   double minLot = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_STEP);
   
   lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
   lotSize = MathRound(lotSize / lotStep) * lotStep;
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Calculate Scalp Stop Loss                                        |
//+------------------------------------------------------------------+
double CalculateScalpStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double stopLossPoints = 15.0; // Tight stop for scalping
   
   if(direction == SIGNAL_SCALP_BUY)
   {
      return entryPrice - (stopLossPoints * point);
   }
   else
   {
      return entryPrice + (stopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Scalp Take Profit                                      |
//+------------------------------------------------------------------+
double CalculateScalpTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   
   if(direction == SIGNAL_SCALP_BUY)
   {
      return entryPrice + (ScalpProfitPoints * point);
   }
   else
   {
      return entryPrice - (ScalpProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Instant Scalp Stop Loss                               |
//+------------------------------------------------------------------+
double CalculateInstantScalpStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double stopLossPoints = 5.0; // Very tight for instant scalping
   
   if(direction == SIGNAL_SCALP_BUY)
   {
      return entryPrice - (stopLossPoints * point);
   }
   else
   {
      return entryPrice + (stopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Instant Scalp Take Profit                             |
//+------------------------------------------------------------------+
double CalculateInstantScalpTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double takeProfitPoints = 8.0; // Quick profit for instant scalping
   
   if(direction == SIGNAL_SCALP_BUY)
   {
      return entryPrice + (takeProfitPoints * point);
   }
   else
   {
      return entryPrice - (takeProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Stop Loss                                              |
//+------------------------------------------------------------------+
double CalculateStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice - (StopLossPoints * point);
   }
   else
   {
      return entryPrice + (StopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Take Profit                                            |
//+------------------------------------------------------------------+
double CalculateTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice + (TakeProfitPoints * point);
   }
   else
   {
      return entryPrice - (TakeProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Volatility Stop Loss                                  |
//+------------------------------------------------------------------+
double CalculateVolatilityStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice, double atr)
{
   double stopLoss = atr * 2.0; // 2x ATR stop loss
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice - stopLoss;
   }
   else
   {
      return entryPrice + stopLoss;
   }
}

//+------------------------------------------------------------------+
//| Calculate Volatility Take Profit                                |
//+------------------------------------------------------------------+
double CalculateVolatilityTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice, double atr)
{
   double takeProfit = atr * 3.0; // 3x ATR take profit
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice + takeProfit;
   }
   else
   {
      return entryPrice - takeProfit;
   }
}

//+------------------------------------------------------------------+
//| Calculate Momentum Stop Loss                                    |
//+------------------------------------------------------------------+
double CalculateMomentumStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double stopLossPoints = 20.0; // Momentum stop
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice - (stopLossPoints * point);
   }
   else
   {
      return entryPrice + (stopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Momentum Take Profit                                  |
//+------------------------------------------------------------------+
double CalculateMomentumTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double takeProfitPoints = 40.0; // Momentum target
   
   if(direction == SIGNAL_BUY)
   {
      return entryPrice + (takeProfitPoints * point);
   }
   else
   {
      return entryPrice - (takeProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Hedge Stop Loss                                        |
//+------------------------------------------------------------------+
double CalculateHedgeStopLoss(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double stopLossPoints = 50.0; // Wider stop for hedging
   
   if(direction == SIGNAL_HEDGE_BUY)
   {
      return entryPrice - (stopLossPoints * point);
   }
   else
   {
      return entryPrice + (stopLossPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Hedge Take Profit                                      |
//+------------------------------------------------------------------+
double CalculateHedgeTakeProfit(ENUM_SIGNAL_TYPE direction, double entryPrice)
{
   double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
   double takeProfitPoints = 30.0; // Conservative target for hedging
   
   if(direction == SIGNAL_HEDGE_BUY)
   {
      return entryPrice + (takeProfitPoints * point);
   }
   else
   {
      return entryPrice - (takeProfitPoints * point);
   }
}

//+------------------------------------------------------------------+
//| Calculate Hedge Lot Size                                         |
//+------------------------------------------------------------------+
double CalculateHedgeLotSize(double totalProfit)
{
   double balance = account.Balance();
   double hedgePercent = 5.0; // 5% for hedging
   double riskAmount = balance * (hedgePercent / 100.0);
   
   // Increase hedge size based on current loss
   if(totalProfit < -100.0)
   {
      riskAmount *= 1.5;
   }
   
   double minLot = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(Symbol, SYMBOL_VOLUME_STEP);
   
   double lotSize = riskAmount / 1000.0; // Simplified calculation
   lotSize = MathMax(minLot, MathMin(maxLot, lotSize));
   lotSize = MathRound(lotSize / lotStep) * lotStep;
   
   return lotSize;
}

//+------------------------------------------------------------------+
//| Execute Flip Mode Strategy                                       |
//+------------------------------------------------------------------+
void ExecuteFlipModeStrategy()
{
   if(!FlipModeActive) return;
   
   // Check if we've reached the target
   if(AccountBalance >= WeeklyTarget)
   {
      FlipModeActive = false;
      Print("ðŸŽ¯ FLIP MODE COMPLETE! Target reached: $", AccountBalance);
      return;
   }
   
   // Generate flip mode signal
   UltraAggressiveSignal flipSignal = GenerateTimeframeSignal(FlipTimeframe, false);
   
   if(flipSignal.direction != SIGNAL_NONE && flipSignal.confidence >= 70.0)
   {
      // Increase lot size for flip mode
      flipSignal.lotSize *= 1.5;
      flipSignal.signalReason = "Flip_Mode";
      
      ExecuteUltraSignal(flipSignal);
   }
}

//+------------------------------------------------------------------+
//| Execute Scalping Strategy                                        |
//+------------------------------------------------------------------+
void ExecuteScalpingStrategy()
{
   // Generate scalping signals
   UltraAggressiveSignal scalpSignal = GenerateTimeframeSignal(PERIOD_M1, true);
   
   if(scalpSignal.direction != SIGNAL_NONE && scalpSignal.confidence >= 65.0)
   {
      if(ActivePositions < MaxSimultaneousPositions)
      {
         ExecuteUltraSignal(scalpSignal);
      }
   }
}

//+------------------------------------------------------------------+
//| Manage All Positions                                             |
//+------------------------------------------------------------------+
void ManageAllPositions()
{
   for(int i = ActivePositions - 1; i >= 0; i--)
   {
      if(position.SelectByTicket(PositionTickets[i]))
      {
         // Update position profit
         PositionProfits[i] = position.Profit();
         
         // Check for quick exit
         if(PositionProfits[i] >= QuickExitPoints)
         {
            trade.PositionClose(PositionTickets[i]);
            RemovePositionFromTracking(i);
            continue;
         }
         
         // Check for trailing stop
         if(TrailingStopPoints > 0)
         {
            ApplyTrailingStop(PositionTickets[i]);
         }
         
         // Check for time-based exit (scalping)
         if(TimeCurrent() - PositionOpenTimes[i] > 300) // 5 minutes
         {
            if(PositionProfits[i] > 0) // Only close if profitable
            {
               trade.PositionClose(PositionTickets[i]);
               RemovePositionFromTracking(i);
            }
         }
      }
      else
      {
         // Position closed externally, remove from tracking
         RemovePositionFromTracking(i);
      }
   }
}

//+------------------------------------------------------------------+
//| Apply Trailing Stop                                              |
//+------------------------------------------------------------------+
void ApplyTrailingStop(ulong ticket)
{
   if(position.SelectByTicket(ticket))
   {
      double point = SymbolInfoDouble(Symbol, SYMBOL_POINT);
      double currentPrice = (position.PositionType() == POSITION_TYPE_BUY) ? 
                           SymbolInfoDouble(Symbol, SYMBOL_BID) : 
                           SymbolInfoDouble(Symbol, SYMBOL_ASK);
      
      double newStopLoss = 0.0;
      
      if(position.PositionType() == POSITION_TYPE_BUY)
      {
         newStopLoss = currentPrice - (TrailingStopPoints * point);
         if(newStopLoss > position.StopLoss())
         {
            trade.PositionModify(ticket, newStopLoss, position.TakeProfit());
         }
      }
      else if(position.PositionType() == POSITION_TYPE_SELL)
      {
         newStopLoss = currentPrice + (TrailingStopPoints * point);
         if(newStopLoss < position.StopLoss() || position.StopLoss() == 0)
         {
            trade.PositionModify(ticket, newStopLoss, position.TakeProfit());
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Remove Position From Tracking                                   |
//+------------------------------------------------------------------+
void RemovePositionFromTracking(int index)
{
   if(index >= 0 && index < ActivePositions)
   {
      // Shift remaining positions
      for(int i = index; i < ActivePositions - 1; i++)
      {
         PositionTickets[i] = PositionTickets[i + 1];
         PositionOpenTimes[i] = PositionOpenTimes[i + 1];
         PositionProfits[i] = PositionProfits[i + 1];
      }
      
      ActivePositions--;
   }
}

//+------------------------------------------------------------------+
//| Update Position Tracking                                         |
//+------------------------------------------------------------------+
void UpdatePositionTracking()
{
   // Clean up closed positions
   for(int i = ActivePositions - 1; i >= 0; i--)
   {
      if(!position.SelectByTicket(PositionTickets[i]))
      {
         RemovePositionFromTracking(i);
      }
   }
}

//+------------------------------------------------------------------+
//| Update Account Info                                              |
//+------------------------------------------------------------------+
void UpdateAccountInfo()
{
   AccountBalance = account.Balance();
   double equity = account.Equity();
   
   CurrentDrawdown = ((InitialBalance - equity) / InitialBalance) * 100.0;
   MaxDrawdown = MathMax(MaxDrawdown, CurrentDrawdown);
   
   if(TotalTrades > 0)
   {
      WinRate = (double)WinningTrades / TotalTrades * 100.0;
   }
}

//+------------------------------------------------------------------+
//| Update Market State                                              |
//+------------------------------------------------------------------+
void UpdateMarketState()
{
   // Get current market data
   double currentPrice = SymbolInfoDouble(Symbol, SYMBOL_ASK);
   double ma20[], ma50[], atr[];
   
   ArraySetAsSeries(ma20, true);
   ArraySetAsSeries(ma50, true);
   ArraySetAsSeries(atr, true);
   
   if(CopyBuffer(MA_Handle_20, 0, 0, 3, ma20) > 0 && 
      CopyBuffer(MA_Handle_50, 0, 0, 3, ma50) > 0 && 
      CopyBuffer(ATR_Handle, 0, 0, 3, atr) > 0)
   {
      marketState.inUptrend = (currentPrice > ma20[0] && ma20[0] > ma50[0]);
      marketState.inDowntrend = (currentPrice < ma20[0] && ma20[0] < ma50[0]);
      marketState.inRange = (!marketState.inUptrend && !marketState.inDowntrend);
      marketState.volatility = atr[0];
      marketState.momentum = (currentPrice - ma20[0]) / ma20[0] * 100;
      marketState.strength = MathAbs(marketState.momentum);
      marketState.opportunity = marketState.strength * (marketState.volatility * 1000);
   }
}

//+------------------------------------------------------------------+
//| Setup Flip Mode Targets                                         |
//+------------------------------------------------------------------+
void SetupFlipModeTargets()
{
   DailyTarget = InitialBalance * 0.58; // 58% daily growth
   WeeklyTarget = 100000.0; // Target $100k from $1k
   FlipModeActive = true;
   
   Print("ðŸš€ Flip Mode Activated - Target: $", WeeklyTarget);
}

//+------------------------------------------------------------------+
//| Log Ultra Aggressive Trade                                       |
//+------------------------------------------------------------------+
void LogUltraAggressiveTrade(UltraAggressiveSignal &signal, ulong ticket)
{
   string logMessage = StringFormat("ðŸ”¥ ULTRA AGGRESSIVE TRADE:\n" +
                                   "Time: %s | Ticket: %d\n" +
                                   "Signal: %s | Reason: %s\n" +
                                   "Entry: %.5f | SL: %.5f | TP: %.5f\n" +
                                   "Lot Size: %.2f | Confidence: %.0f%%\n" +
                                   "Expected Profit: $%.2f\n" +
                                   "Active Positions: %d/%d",
                                   TimeToString(TimeCurrent()),
                                   ticket,
                                   EnumToString(signal.direction),
                                   signal.signalReason,
                                   signal.entryPrice,
                                   signal.stopLoss,
                                   signal.takeProfit,
                                   signal.lotSize,
                                   signal.confidence,
                                   signal.expectedProfit,
                                   ActivePositions,
                                   MaxSimultaneousPositions);
   
   Print(logMessage);
}

//+------------------------------------------------------------------+
//| Create Ultra Notification                                        |
//+------------------------------------------------------------------+
string CreateUltraNotification(UltraAggressiveSignal &signal)
{
   return StringFormat("ðŸ”¥ ULTRA AGGRESSIVE SIGNAL!\n" +
                      "Signal: %s | Confidence: %.0f%%\n" +
                      "Entry: %.5f | Expected: $%.2f\n" +
                      "Reason: %s\n" +
                      "Active: %d/%d positions",
                      EnumToString(signal.direction),
                      signal.confidence,
                      signal.entryPrice,
                      signal.expectedProfit,
                      signal.signalReason,
                      ActivePositions,
                      MaxSimultaneousPositions);
}

//+------------------------------------------------------------------+
//| Save Ultra Aggressive Stats                                      |
//+------------------------------------------------------------------+
void SaveUltraAggressiveStats()
{
   Print("ðŸ”¥ ULTRA AGGRESSIVE TRADING SESSION COMPLETE");
   Print("ðŸ’° Total Trades: ", TotalTrades);
   Print("ðŸŽ¯ Win Rate: ", WinRate, "%");
   Print("ðŸ’µ Final Balance: $", AccountBalance);
   Print("ðŸ“Š Max Drawdown: ", MaxDrawdown, "%");
   Print("âš¡ Max Active Positions: ", ActivePositions);
   Print("ðŸš€ Flip Mode Status: ", FlipModeActive ? "ACTIVE" : "COMPLETE");
}

//+------------------------------------------------------------------+
